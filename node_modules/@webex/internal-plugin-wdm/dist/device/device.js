'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _desc, _value, _obj; /*!
                                                                                        * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
                                                                                        */

var _common = require('@webex/common');

var _commonTimers = require('@webex/common-timers');

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _featuresModel = require('./features-model');

var _featuresModel2 = _interopRequireDefault(_featuresModel);

var _serviceCollection = require('./service-collection');

var _serviceCollection2 = _interopRequireDefault(_serviceCollection);

var _webexCore = require('@webex/webex-core');

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * Decides if this device should be persisted to boundedStorage, based on
 * this.config.ephemeral.
 * @returns {Boolean}
 */
function decider() {
  return !this.config.ephemeral;
}

var Device = _webexCore.WebexPlugin.extend((_dec = (0, _webexCore.waitForValue)('@'), _dec2 = (0, _webexCore.waitForValue)('@'), _dec3 = (0, _webexCore.persist)('@', decider), _dec4 = (0, _webexCore.waitForValue)('@'), _dec5 = (0, _webexCore.waitForValue)('@'), _dec6 = (0, _webexCore.waitForValue)('@'), _dec7 = (0, _webexCore.waitForValue)('@'), _dec8 = (0, _webexCore.waitForValue)('@'), _dec9 = (0, _webexCore.waitForValue)('@'), (_obj = {
  children: {
    features: _featuresModel2.default
  },

  collections: {
    serviceCatalog: _serviceCollection2.default
  },

  idAttribute: 'url',

  namespace: 'Device',

  props: {
    /**
     * Notifies the client if giphys are enabled.
     * Currently, the values for it are:
     * - ALLOW
     * - BLOCK
     * @instance
     * @memberof Device
     * @type {string}
     */
    clientMessagingGiphy: 'string',
    customerCompanyName: 'string',
    customerLogoUrl: 'string',
    // deviceType doesn't have any real value, but we need to send it during
    // device refresh to make sure we don't get back an ios device url
    deviceType: 'string',
    helpUrl: 'string',
    intranetInactivityDuration: 'number',
    intranetInactivityCheckUrl: 'string',
    inNetworkInactivityDuration: 'number', // Newly added duration for internal network inactivity
    /**
     * Is ECM (external content management) enabled for the whole org
     * @instance
     * @memberof Device
     * @type {boolean}
     */
    ecmEnabledForAllUsers: {
      type: 'boolean',
      default: function _default() {
        return false;
      }
    },
    /**
     * What ECM providers are available
     * @instance
     * @memberof Device
     * @type {string[]}
     */
    ecmSupportedStorageProviders: {
      type: 'array',
      default: function _default() {
        return [];
      }
    },
    modificationTime: 'string',
    partnerCompanyName: 'string',
    partnerLogoUrl: 'string',
    peopleInsightsEnabled: 'boolean',
    reportingSiteDesc: 'string',
    reportingSiteUrl: 'string',
    searchEncryptionKeyUrl: 'string',
    // services is obsoleted and will be deprecated
    services: {
      // Even though @jodykstr will tell you the docs claim you don't need to
      // initialize `object` properties, the docs lie.
      default: function _default() {
        return {};
      },

      type: 'object'
    },
    serviceHostMap: {
      default: function _default() {
        return {
          serviceLinks: {},
          hostCatalog: {}
        };
      },

      type: 'object'
    },
    showSupportText: 'boolean',
    supportProviderCompanyName: 'string',
    supportProviderLogoUrl: 'string',
    url: 'string',
    userId: 'string',
    /**
     * Notifies the client if file sharing is disabled.
     * Currently, the values for it are:
     * - BLOCK_BOTH
     * - BLOCK_UPLOAD
     * @instance
     * @memberof Device
     * @type {string}
     */
    webFileShareControl: 'string',
    webSocketUrl: 'string',
    /**
     * Notifies the client if whiteboarding should be allowed
     * regardless of webFileShareControl settings.
     * Currently, the values for it are:
     * - ALLOW
     * - BLOCK
     * @instance
     * @memberof Device
     * @type {string}
     */
    whiteboardFileShareControl: 'string'
  },

  derived: {
    registered: {
      deps: ['url'],
      fn: function fn() {
        return Boolean(this.url);
      }
    }
  },

  session: {
    // Fun Fact: setTimeout returns a Timer object instead of a Number in Node 6
    // or later
    logoutTimer: 'any',
    lastUserActivityDate: 'number',
    isReachabilityChecked: 'boolean', // To prevent url reachabilty from being called more than once on successful check.
    isInMeeting: 'boolean', // Boolean for checking user is in meeting to prevent in advertent timeout due to inactivity
    isInNetwork: 'boolean' // Boolean to ensure _resetLogoutTimer isn't called repeatedly once its known client is connected to org's internal network
  },

  determineService: function determineService(url) {
    var feature = this.features.developer.get('web-high-availability');

    if (feature && feature.value) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(this.serviceHostMap.serviceLinks)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          var serviceUrl = this.serviceHostMap.serviceLinks[key];

          if (url.startsWith(serviceUrl)) {
            return _promise2.default.resolve(key);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(this.services)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _key = _step2.value;

          var _serviceUrl = this.services[_key];

          if (url.startsWith(_serviceUrl)) {
            // "ServiceUrl" is 10 characters
            return _promise2.default.resolve(_key.substr(0, _key.length - 10));
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    return _promise2.default.reject(new Error(url + ' does not reflect a known service'));
  },
  getServiceUrl: function getServiceUrl(service) {
    var _this = this;

    var feature = this.features.developer.get('web-high-availability');

    if (feature && feature.value) {
      return this._getServiceUrl(this.serviceHostMap.serviceLinks, service).then(function (isServiceUrl) {
        return isServiceUrl || _this.getPreDiscoveryServiceUrl(service);
      });
    }

    return this._getServiceUrl(this.services, service).then(function (isServiceUrl) {
      return isServiceUrl || _this.getPreDiscoveryServiceUrl(service);
    });
  },
  getPreDiscoveryServiceUrl: function getPreDiscoveryServiceUrl(service) {
    // The Promise.resolve here is temporary. A future PR will make the
    // corresponding _ method async to allow for lazy device registration
    return _promise2.default.resolve(this._getServiceUrl(this.config.preDiscoveryServices, service));
  },
  getWebSocketUrl: function getWebSocketUrl() {
    return this.useServiceCatalogUrl(this.webSocketUrl);
  },
  useServiceCatalogUrl: function useServiceCatalogUrl(uri) {
    return this.serviceCatalog.inferServiceFromUrl(uri).then(function (s) {
      return s.replaceUrlWithCurrentHost(uri);
    });
  },
  markUrlFailedAndGetNew: function markUrlFailedAndGetNew(url) {
    var _this2 = this;

    if (!url) {
      return _promise2.default.reject(new Error('`url` is a required parameter'));
    }

    this.logger.info('device: marking ' + url + ' as failed');

    return this.serviceCatalog.markFailedAndCycleUrl(url).then(function (uri) {
      _this2.webex.internal.metrics.submitClientMetrics('web-ha', {
        tags: {
          action: 'replace_url',
          failedUrl: url,
          newUrl: uri
        }
      });

      return uri;
    })
    // it's likely we fail here because we've cycled though all hosts,
    // reset all hosts and then retry connecting
    .catch(function () {
      return _this2._resetAllAndRetry(url);
    });
  },
  _resetAllAndRetry: function _resetAllAndRetry(url) {
    if (!url) {
      return _promise2.default.reject(new Error('`url` is a required parameter'));
    }

    this.logger.info('device: reset available hosts and retry ' + url);

    return this.serviceCatalog.resetAllAndRetry(url);
  },


  // this function is exposed beyond the device file
  fetchNewUrls: function fetchNewUrls(url) {
    var _this3 = this;

    // we want to get the current service first, just in case the
    // refreshed catalog has different host names
    return new _promise2.default(function (resolve) {
      return _this3.serviceCatalog.inferServiceFromUrl(url).then(function (s) {
        _this3.logger.info('device: refresh to ' + s.service + ' get new urls');
        _this3.refresh();
        _this3.on('serviceCatalogUpdated', function () {
          return resolve(s.url);
        });
      });
    });
  },
  initialize: function initialize() {
    var _this4 = this;

    for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {
      args[_key2] = arguments[_key2];
    }

    (0, _apply2.default)(_webexCore.WebexPlugin.prototype.initialize, this, args);

    // Propagate change(:[attribute]) events from collections
    ['developer', 'entitlement', 'user'].forEach(function (collectionName) {
      _this4.features.on('change:' + collectionName, function (model, value, options) {
        _this4.trigger('change', _this4, options);
        _this4.trigger('change:features', _this4, _this4.features, options);
      });
    });

    // Initialize it to false.
    this.isReachabilityChecked = false;

    this.on('change:serviceHostMap', this._updateServiceCatalog);

    this.listenToAndRun(this, 'change:intranetInactivityCheckUrl', function () {
      _this4.testNetworkReachability();
    });
    this.listenToAndRun(this, 'change:intranetInactivityDuration', function () {
      _this4.testNetworkReachability();
    });
    this.listenToAndRun(this, 'change:inNetworkInactivityDuration', function () {
      _this4.testNetworkReachability();
    });
    this.listenTo(this.webex, 'user-activity', function () {
      _this4.lastUserActivityDate = Date.now();
    });
    /**
    * Meeting started and ended event listenrs
    * When client enters into the meeting set isInMeeting to true
    * This tells also triggers both the timers inturn un-setting the timers until meeting ends
    * On meeting end/clean-up the timers are reset.
    */
    this.listenTo(this.webex, 'meeting started', function () {
      _this4.isInMeeting = true;
      _this4._resetLogoutTimer();
    });
    this.listenTo(this.webex, 'meeting ended', function () {
      _this4.isInMeeting = false;
      _this4._resetLogoutTimer();
    });
  },


  /**
  * Don't log the features object
  * @param {number} depth
  * @returns {Object}
  */
  inspect: function inspect(depth) {
    return _util2.default.inspect((0, _omit3.default)(this.serialize(), 'features'), { depth: depth });
  },
  isPreDiscoveryService: function isPreDiscoveryService(service) {
    // The Promise.resolve here is temporary. A future PR will make the
    // corresponding _ method async to allow for lazy device registration
    return _promise2.default.resolve(this._isService(this.config.preDiscoveryServices, service));
  },


  /**
  * Meeting started and Meeting Ended
  * These are device.internal functions that can be accessible from web-client
  * These are used to trigger the events for meeting start/end from within web client.
  * @returns {boolean}
  */
  meetingStarted: function meetingStarted() {
    this.webex.trigger('meeting started');
  },

  /**
  * Meeting started and Meeting Ended
  * These are device.internal functions that can be accessible from web-client
  * These are used to trigger the events for meeting start/end from within web client.
  * @returns {boolean}
  */
  meetingEnded: function meetingEnded() {
    this.webex.trigger('meeting ended');
  },
  testNetworkReachability: function testNetworkReachability() {
    var _this5 = this;

    if (this.isReachabilityChecked) {
      return this._resetLogoutTimer();
    }

    if (!this.intranetInactivityCheckUrl) {
      this.isInNetwork = false;

      return this._resetLogoutTimer();
    }

    this.isReachabilityChecked = true;
    this.webex.request({
      headers: {
        'cisco-no-http-redirect': null,
        'spark-user-agent': null,
        trackingid: null
      },
      method: 'GET',
      uri: this.intranetInactivityCheckUrl
    }).then(function () {
      _this5.isInNetwork = true;

      return _this5._resetLogoutTimer();
    }).catch(function () {
      _this5.logger.info('device: did not reach internal ping endpoint; Setting off-network timer');
      _this5.isInNetwork = false;

      return _this5._resetLogoutTimer();
    });

    // Added due to eslint error.
    return true;
  },
  isPreDiscoveryServiceUrl: function isPreDiscoveryServiceUrl(uri) {
    if (!uri) {
      return _promise2.default.reject(new Error('`uri` is a required parameter'));
    }

    // The Promise.resolve here is temporary. A future PR will make the
    // corresponding _ method async to allow for lazy device registration
    return _promise2.default.resolve(this._isServiceUrl(this.config.preDiscoveryServices, uri));
  },
  isService: function isService(service) {
    var _this6 = this;

    if (service === 'idbroker') {
      return _promise2.default.resolve(false);
    }
    var feature = this.features.developer.get('web-high-availability');

    if (feature && feature.value) {
      return this._isService(this.serviceHostMap.serviceLinks, service).then(function (_isService) {
        return _isService || _this6.isPreDiscoveryService(service);
      });
    }

    return this._isService(this.services, service).then(function (_isService) {
      return _isService || _this6.isPreDiscoveryService(service);
    });
  },
  isServiceUrl: function isServiceUrl(uri) {
    // The Promise.resolve here is temporary. A future PR will make the
    // corresponding _ method async to allow for lazy device registration
    if (!uri) {
      return _promise2.default.reject(new Error('`uri` is a required parameter'));
    }
    var feature = this.features.developer.get('web-high-availability');

    if (feature && feature.value) {
      if (this._isServiceUrl(this.serviceHostMap.serviceLinks, uri) || this._isServiceUrlFromCatalog(this.serviceHostMap.hostCatalog, uri)) {
        return _promise2.default.resolve(true);
      }

      return _promise2.default.resolve(false);
    }

    return _promise2.default.resolve(this._isServiceUrl(this.services, uri));
  },
  isSpecificService: function isSpecificService(service, key) {
    if (key === service) {
      return _promise2.default.resolve(true);
    }

    return this.getServiceUrl(service).then(function (serviceUrl) {
      return key.includes(serviceUrl);
    });
  },
  _getServiceUrl: function _getServiceUrl(target, service) {
    /* istanbul ignore if */
    if (!service) {
      return _promise2.default.reject(new Error('`service` is a required parameter'));
    }

    var feature = this.features.developer.get('web-high-availability');

    if (feature && feature.value) {
      var s = this.serviceCatalog.get(service);

      if (s) {
        return _promise2.default.resolve(s.url);
      }
    }

    if (!target) {
      return _promise2.default.reject(new Error('`target` is a required parameter'));
    }

    return _promise2.default.resolve(target[service + 'ServiceUrl']);
  },
  _isService: function _isService(target, service) {
    return this._getServiceUrl(target, service).then(function (url) {
      return Boolean(url);
    });
  },
  _isServiceUrl: function _isServiceUrl(target, uri) {
    var feature = this.features.developer.get('web-high-availability');

    if (feature && feature.value) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator3.default)((0, _keys2.default)(target)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var key = _step3.value;

          var serviceUrl = target[key];

          if (key !== 'idbroker' && uri.startsWith(serviceUrl)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    } else {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator3.default)((0, _values2.default)(target)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var value = _step4.value;

          if (value && uri.startsWith(value)) {
            return _promise2.default.resolve(true);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }

    return false;
  },
  _isServiceUrlFromCatalog: function _isServiceUrlFromCatalog(hostCatalog, uri) {
    var hostName = _url2.default.parse(uri).hostname;

    if (hostName && !hostName.includes('idbroker') && (0, _find3.default)(hostCatalog, function (service) {
      return (0, _find3.default)(service, function (availableHost) {
        return availableHost.host === hostName;
      });
    })) {
      return true;
    }

    return false;
  },
  refresh: function refresh() {
    var _this7 = this;

    this.logger.info('device: refreshing');

    if (!this.registered) {
      this.logger.info('device: device not registered, registering');

      return this.register();
    }

    var body = (0, _omit3.default)(this.serialize(), 'features', 'mediaClusters');

    if (this.config.ephemeral) {
      body.ttl = this.config.ephemeralDeviceTTL;
    }

    return this.request({
      method: 'PUT',
      uri: this.url,
      body: body
    }).then(function (res) {
      return _this7._processRegistrationSuccess(res);
    }).catch(function (reason) {
      if (reason.statusCode === 404) {
        // If we get a 404, it means the device is no longer valid and we need
        // to register a new one.
        _this7.logger.info('device: refresh failed with 404, attempting to register new device');
        _this7.clear();

        return _this7.register();
      }

      return _promise2.default.reject(reason);
    });
  },
  register: function register() {
    var _this8 = this;

    /* eslint no-invalid-this: [0] */
    this.logger.info('device: registering');

    if (this.registered) {
      this.logger.info('device: device already registered, refreshing');

      return this.refresh();
    }

    var body = this.config.defaults;

    if (this.config.ephemeral) {
      body.ttl = this.config.ephemeralDeviceTTL;
    }

    return this.request({
      method: 'POST',
      service: 'wdm',
      resource: 'devices',
      body: body
    }).then(function (res) {
      return _this8._processRegistrationSuccess(res);
    });
  },
  unregister: function unregister() {
    var _this9 = this;

    this.logger.info('device: unregistering');

    if (!this.url) {
      this.logger.warn('device: not registered');

      return _promise2.default.resolve();
    }

    return this.request({
      uri: this.url,
      method: 'DELETE'
    }).then(function () {
      return _this9.clear();
    });
  },
  clear: function clear() {
    clearTimeout(this.refreshTimer);

    for (var _len2 = arguments.length, args = Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
      args[_key3] = arguments[_key3];
    }

    (0, _apply2.default)(_webexCore.WebexPlugin.prototype.clear, this, args);
  },
  _processRegistrationSuccess: function _processRegistrationSuccess(res) {
    var _this10 = this;

    this.logger.info('device: received registration payload');
    this.set(res.body);
    if (this.config.ephemeral) {
      this.logger.info('device: enqueing device refresh');
      var delay = (this.config.ephemeralDeviceTTL / 2 + 60) * 1000;

      this.refreshTimer = (0, _commonTimers.safeSetTimeout)(function () {
        return _this10.refresh();
      }, delay);
    }
  },
  _updateServiceCatalog: function _updateServiceCatalog(newRegistration) {
    var _this11 = this;

    var feature = this.features.developer.get('web-high-availability');

    if (feature && feature.value) {
      if (newRegistration.serviceHostMap && newRegistration.serviceHostMap.serviceLinks && newRegistration.serviceHostMap.hostCatalog) {
        (0, _keys2.default)(newRegistration.serviceHostMap.serviceLinks).forEach(function (key) {
          var hostName = _url2.default.parse(newRegistration.serviceHostMap.serviceLinks[key]).hostname;
          var hosts = newRegistration.serviceHostMap.hostCatalog[hostName];

          _this11.serviceCatalog.set({
            service: key,
            defaultUrl: newRegistration.serviceHostMap.serviceLinks[key],
            availableHosts: hosts || []
          }, { remove: false });
        });
        this.trigger('serviceCatalogUpdated');
      } else {
        // if user has old device in localStorage, refresh device
        this.refresh();
      }
    }
  },
  _resetLogoutTimer: function _resetLogoutTimer() {
    // Clear any previously set timers and listeners
    clearTimeout(this.logoutTimer);
    this.off('change:lastUserActivityDate'); // removes previous event listener
    this.unset('logoutTimer');

    if (!this.isInMeeting && this.config.enableInactivityEnforcement && this.isReachabilityChecked) {
      if (this.isInNetwork) {
        this._setLogoutTimer(this.inNetworkInactivityDuration);
      } else {
        this._setLogoutTimer(this.intranetInactivityDuration);
      }
    }
  },
  _setLogoutTimer: function _setLogoutTimer(duration) {
    var _this12 = this;

    if (!duration || duration && duration === -1) {
      return;
    }
    this.on('change:lastUserActivityDate', function () {
      _this12._resetLogoutTimer();
    });
    var timer = (0, _commonTimers.safeSetTimeout)(function () {
      _this12.webex.logout();
    }, duration * 1000);

    this.logoutTimer = timer;
  },
  version: '1.72.6'
}, (_applyDecoratedDescriptor(_obj, 'determineService', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'determineService'), _obj), _applyDecoratedDescriptor(_obj, 'getServiceUrl', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'getServiceUrl'), _obj), _applyDecoratedDescriptor(_obj, 'initialize', [_dec3], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initialize'), _obj), _applyDecoratedDescriptor(_obj, 'isService', [_dec4], (0, _getOwnPropertyDescriptor2.default)(_obj, 'isService'), _obj), _applyDecoratedDescriptor(_obj, 'isServiceUrl', [_dec5], (0, _getOwnPropertyDescriptor2.default)(_obj, 'isServiceUrl'), _obj), _applyDecoratedDescriptor(_obj, 'isSpecificService', [_dec6], (0, _getOwnPropertyDescriptor2.default)(_obj, 'isSpecificService'), _obj), _applyDecoratedDescriptor(_obj, 'refresh', [_common.oneFlight, _dec7], (0, _getOwnPropertyDescriptor2.default)(_obj, 'refresh'), _obj), _applyDecoratedDescriptor(_obj, 'register', [_common.oneFlight, _dec8], (0, _getOwnPropertyDescriptor2.default)(_obj, 'register'), _obj), _applyDecoratedDescriptor(_obj, 'unregister', [_common.oneFlight, _dec9], (0, _getOwnPropertyDescriptor2.default)(_obj, 'unregister'), _obj)), _obj)));

exports.default = Device;
//# sourceMappingURL=device.js.map
