'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

require('@webex/internal-plugin-mercury');

var _webexCore = require('@webex/webex-core');

var _metrics = require('../metrics');

var _metrics2 = _interopRequireDefault(_metrics);

var _config = require('../metrics/config');

var _loggerConfig = require('../common/logs/logger-config');

var _loggerConfig2 = _interopRequireDefault(_loggerConfig);

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _triggerProxy = require('../common/events/trigger-proxy');

var _triggerProxy2 = _interopRequireDefault(_triggerProxy);

var _constants = require('../constants');

var _meetingInfo = require('../meeting-info');

var _meetingInfo2 = _interopRequireDefault(_meetingInfo);

var _meeting = require('../meeting');

var _meeting2 = _interopRequireDefault(_meeting);

var _personalMeetingRoom = require('../personal-meeting-room');

var _personalMeetingRoom2 = _interopRequireDefault(_personalMeetingRoom);

var _reachability = require('../reachability');

var _reachability2 = _interopRequireDefault(_reachability);

var _request = require('../meetings/request');

var _request2 = _interopRequireDefault(_request);

var _analyzer = require('../analyzer/analyzer');

var _analyzer2 = _interopRequireDefault(_analyzer);

var _calculator = require('../analyzer/calculator');

var _calculator2 = _interopRequireDefault(_calculator);

var _collection = require('./collection');

var _collection2 = _interopRequireDefault(_collection);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
   * Meetings Ready Event
   * Emitted when the meetings instance on webex is ready
   * @event meetings:ready
   * @instance
   * @memberof Meetings
   */

/**
    * Meeting Removed Event
    * Emitted when a meeting was removed from the cache of meetings
    * @event meeting:removed
    * @instance
    * @type {Object}
    * @property {String} meetingId the removed meeting
    * @property {Object} response the server response
    * @property {String} type what type of meeting it was
    * @memberof Meetings
    */

/**
    * Meeting Added Event
    * Emitted when a meeting was added to the cache of meetings
    * @event meeting:added
    * @instance
    * @type {Object}
    * @property {String} meetingId the added meeting
    * @property {String} type what type of meeting it was
    * @memberof Meetings
    */

/**
   * Maintain a cache of meetings and sync with services.
   * @class
   */
var Meetings = function (_WebexPlugin) {
  (0, _inherits3.default)(Meetings, _WebexPlugin);

  /**
   * Initializes the Meetings Plugin
   * @constructor
   * @public
   * @memberof Meetings
   */
  function Meetings() {
    var _ref;

    (0, _classCallCheck3.default)(this, Meetings);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    /**
     * The MeetingInfo object to interact with server
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = Meetings.__proto__ || (0, _getPrototypeOf2.default)(Meetings)).call.apply(_ref, [this].concat(args)));

    _this.namespace = _constants.MEETINGS;
    _this.meetingInfo = new _meetingInfo2.default({}, { parent: _this.webex });
    /**
     * The Meetings request to interact with server
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */
    _this.request = new _request2.default({}, { parent: _this.webex });
    _this.meetingCollection = new _collection2.default();
    /**
     * The PersonalMeetingRoom object to interact with server
     * @instance
     * @type {Object}
     * @public
     * @memberof Meetings
     */
    _this.personalMeetingRoom = new _personalMeetingRoom2.default({}, { parent: _this.webex });
    /**
     * The Reachability object to interact with server, starts as null until {@link Meeting#setReachability} is called
     * starts as null
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */
    _this.reachability = null;
    _this.onReady();
    _metrics2.default.initialSetup(_this.meetingCollection, _this.webex.version);
    return _this;
  }

  /**
   * handle locus events and takes meeting actions with them as they come in
   * @param {Object} data a locus event
   * @param {String} data.locusUrl
   * @param {Object} data.locus
   * @param {String} data.eventType
   * @returns {undefined}
   * @private
   * @memberof Meetings
   */


  (0, _createClass3.default)(Meetings, [{
    key: 'handleLocusEvent',
    value: function handleLocusEvent(data) {
      var _this2 = this;

      var meeting = null;

      // getting meeting by correlationId. This will happen for the new event
      // Either the locus
      // TODO : Add check for the callBack Address
      meeting = this.meetingCollection.getByKey(_constants.LOCUS_URL, data.locusUrl) || this.meetingCollection.getByKey(_constants.CORRELATION_ID, _util2.default.checkForCorrelationId(this.webex.internal.device.url, data.locus)) || this.meetingCollection.getByKey(_constants.SIP_URI, data.locus.self && data.locus.self.callbackInfo && data.locus.self.callbackInfo.callbackAddress);

      if (!meeting) {
        // TODO: create meeting when we get a meeting object
        // const checkForEnded = (locus) => {
        // TODO: you already ended the meeting but you got an event later
        // Mainly for 1:1 Callsor meeting
        // Happens mainly after refresh

        // 1:1 Meeting
        // 1)  You ended a call before but you got a mercury event
        // Make sure end the call and cleanup the meeting only if the mercury
        // event says so
        // 2) Maintain lastSync time in the meetings object which helps to compare
        // If the meeting came befor or after the sync . ANy meeting start time before the sync time is invalid

        // For space Meeting
        // Check the locus object and see who has joined

        // };
        // rather then locus object change to locus url

        if (data.locus && data.locus.fullState && data.locus.fullState.state === _constants.LOCUS.STATE.INACTIVE) {
          // just ignore the event as its already ended and not active
          _loggerProxy2.default.logger.warn('Meetings->handleLocusEvent#Locus event received for meeting, after it was ended.');

          return;
        }
        this.create(data.locus, _constants._LOCUS_ID_).then(function (newMeeting) {
          meeting = newMeeting;

          if (data.eventType === _constants.LOCUSEVENT.DIFFERENCE) {
            // its a delta object and we have a new meeting
            meeting.locusInfo.initialSetup(data.locus, meeting);
          } else {
            // Its a new meeting and have a fresh locus object
            meeting.locusInfo.initialSetup(data.locus);
          }
        }).finally(function () {
          // Had to put `meeting:added here as the parsing of the locus object is done here
          _metrics2.default.postEvent({ event: _config.eventType.NOTIFICATION_RECEIVED, meeting: meeting, data: { trigger: _config.trigger.MERCURY_EVENT } });

          _metrics2.default.postEvent({ event: _config.eventType.REMOTE_STARTED, meeting: meeting, data: { trigger: _config.trigger.MERCURY_EVENT } });
          _triggerProxy2.default.trigger(_this2, {
            file: 'meetings',
            function: 'handleLocusEvent'
          }, _constants.EVENT_TRIGGERS.MEETING_ADDED, {
            meeting: meeting,
            type: meeting.type === _constants._MEETING_ ? _constants._JOIN_ : _constants._INCOMING_
          });
        });
      } else {
        _metrics2.default.postEvent({ event: _config.eventType.NOTIFICATION_RECEIVED, meeting: meeting, data: { trigger: _config.trigger.MERCURY_EVENT } });
        meeting.locusInfo.parse(meeting, data);
      }
    }

    /**
     * handles locus events through mercury that are not roap
     * @param {Object} envelope
     * @param {Object} envelope.data
     * @param {String} envelope.data.eventType
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'handleLocusMercury',
    value: function handleLocusMercury(envelope) {
      var data = envelope.data;
      var eventType = data.eventType;


      if (eventType && eventType !== _constants.LOCUSEVENT.MESSAGE_ROAP) {
        this.handleLocusEvent(data);
      }
    }

    /**
     * registers for locus and roap mercury events
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'listenForEvents',
    value: function listenForEvents() {
      var _this3 = this;

      this.webex.internal.mercury.on(_constants.LOCUSEVENT.LOCUS_MERCURY, function (envelope) {
        _this3.handleLocusMercury(envelope);
      });
      this.webex.internal.mercury.on(_constants.ROAP.ROAP_MERCURY, function (envelope) {
        _util2.default.handleRoapMercury(envelope, _this3.meetingCollection);
      });
    }

    /**
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'onReady',
    value: function onReady() {
      var _this4 = this;

      this.webex.once(_constants.READY, function () {
        _loggerConfig2.default.set(_this4.config.logging);
        _loggerProxy2.default.set(_this4.webex.logger);
        if (_this4.webex.canAuthorize) {
          _this4.listenForEvents();
          // this.listenInternal();
          _triggerProxy2.default.trigger(_this4, {
            file: 'meetings',
            function: 'onReady'
          }, _constants.EVENT_TRIGGERS.MEETINGS_READY);
        }
      });
    }

    /**
     * initializes the reachability instance for Meetings
     * @returns {undefined}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'setReachability',
    value: function setReachability() {
      this.reachability = new _reachability2.default({}, { parent: this.webex });
    }

    /**
     * gets the reachability instance for Meetings
     * @returns {Reachability}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'getReachability',
    value: function getReachability() {
      return this.reachability;
    }

    /**
     * initializes and starts gathering reachability for Meetings
     * @returns {undefined}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'startReachability',
    value: function startReachability() {
      if (!this.reachability) {
        this.setReachability();
      }
      this.getReachability().gatherReachability();
    }

    /**
     * gets the personal meeting room instance, for saved PMR values for this user
     * @returns {PersonalMeetingRoom}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'getPersonalMeetingRoom',
    value: function getPersonalMeetingRoom() {
      return this.personalMeetingRoom;
    }

    /**
     * @param {String} meetingId
     * @param {Object} response
     * @param {String} type
     * @returns {Object}
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'destroy',
    value: function destroy(meetingId, response) {
      this.meetingCollection.delete(meetingId);
      _triggerProxy2.default.trigger(this, {
        file: 'meetings',
        function: 'destroy'
      }, _constants.EVENT_TRIGGERS.MEETING_REMOVED, {
        meetingId: meetingId,
        response: response
      });

      return response;
    }

    /**
     * Create a meeting.
     * @param {string} destination - sipURL, spaceId, phonenumber, meeting link, or locus object}
     * @param {string} [type] - the optional specified type, such as locusId
     * @returns {Promise} A new Meeting.
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'create',
    value: function create(destination) {
      var _this5 = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      // TODO: type should be from a dictionary
      // Check if there is already meeting
      var meeting = this.meetingCollection.getByKey(_constants.SIP_URI, destination);

      if (!meeting) {
        return this.createMeeting(destination, type).then(function (meeting) {
          if (meeting && meeting.on) {
            meeting.on(_constants.EVENTS.DESTROY_MEETING, function (payload) {
              _this5.destroy(payload.meetingId, payload.response);
            });
          } else {
            _loggerProxy2.default.logger.error('meetings->create#ERROR, meeting does not have on method, will not be destroyed, meeting cleanup impossible for meeting: ' + meeting);
          }

          return _promise2.default.resolve(meeting);
        });
      }

      return _promise2.default.resolve(meeting);
    }

    /**
     * @param {String} destination see create()
     * @param {String} type see create()
     * @returns {Promise} a new meeting instance complete with meeting info and destination
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'createMeeting',
    value: function createMeeting(destination) {
      var _this6 = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var meeting = new _meeting2.default({
        userId: this.webex.internal.device.userId,
        deviceUrl: this.webex.internal.device.url,
        roapSeq: 0,
        locus: type === _constants._LOCUS_ID_ ? destination : null // pass the locus object if present
      }, {
        parent: this.webex
      });

      this.meetingCollection.set(meeting);

      return this.meetingInfo.fetchMeetingInfo(_util2.default.extractDestination(destination, type), type).then(function (info) {
        meeting.parseMeetingInfo(info);
        meeting.meetingInfo = info;

        return meeting;
      }).catch(function (err) {
        _loggerProxy2.default.logger.error('Meetings->createMeeting#Error ' + err + ' fetching /meetingInfo for creation, continuing.');
        // if there is no meeting info we assume its a 1:1 call or wireless share
        // We need to save this info for future reference
        meeting.destination = destination;

        return meeting;
      }).finally(function () {
        // For type LOCUS_ID we need to parse the locus object to get the information
        // about the caller and callee
        // TODO: check for a better solution
        if (type === _constants._LOCUS_ID_) {
          return;
        }

        if (!meeting.sipUri) {
          meeting.setSipUri(destination);
        }
        // TODO: check if we have to move this to parser
        var meetingAddedType = _util2.default.getMeetingAddedType(type);

        // We typically shouldn't need to trigger both and event and return a promise.
        // Is this a special case? We want to make the public API usage as simple as possible.
        _triggerProxy2.default.trigger(_this6, {
          file: 'meetings',
          function: 'createMeeting'
        }, _constants.EVENT_TRIGGERS.MEETING_ADDED, {
          meeting: meeting,
          type: meetingAddedType
        });
      });

      // Create the meeting calling the necessary service endpoints.

      // Internally, there are many more destinations:
      //
      // - locusID
      // - meetingURL
      // - globalMeetingID, e.g, *00*meetingID
      // - meetingID
      // - meetingURL
      // - PSTN
      // - phone number
      //
      // Our job is to determine the appropriate one
      // and its corresponding service so that developers
      // need only sipURL or spaceID to get a meeting
      // and its ID, but have the option to use createWithType()
      // and specify those types to get meetingInfo
    }

    /**
     * get a specifc meeting given it's type matched to the value, i.e., locus url
     * @param {String} type
     * @param {Object} value
     * @returns {Meeting}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'getMeetingByType',
    value: function getMeetingByType(type, value) {
      return this.meetingCollection.getByKey(type, value);
    }

    /**
     * Get all meetings.
     * @param {object} options
     * @param {object} options.startDate - get meetings after this start date
     * @param {object} options.endDate - get meetings before this end date
     * @returns {Object} All active and scheduled meetings.
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'getAllMeetings',
    value: function getAllMeetings() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // Options may include other parameters to filter this collection
      // of meetings.
      return this.meetingCollection.getAll(options);
    }

    /**
     * syncs all the meeting from server
     * @returns {undefined}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'syncMeetings',
    value: function syncMeetings() {
      var _this7 = this;

      return this.request.getActiveMeetings().then(function (locus) {
        if (locus.loci && locus.loci.length > 0) {
          locus.loci.forEach(function (locus) {
            _this7.handleLocusEvent({
              locus: locus,
              locusUrl: locus.url
            });
          });
        }
      });
    }

    /**
     * Get all scheduled meetings.
     * @param {object} options
     * @param {object} options.startDate - get meetings after this start date
     * @param {object} options.endDate - get meetings before this end date
     * @returns {Object} All scheduled meetings.
     * @memberof Meetings
     */

  }, {
    key: 'getScheduledMeetings',
    value: function getScheduledMeetings() {
      return this.meetingCollection.getAll({ scheduled: true });
    }

    /**
     * Get the logger instance for plugin-meetings
     * @returns {Logger}
     */

  }, {
    key: 'getLogger',
    value: function getLogger() {
      return _loggerProxy2.default.get();
    }

    /**
     * Get the Stats Analyzer singleton
     * @returns {StatsAnalyzer}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'getAnalyzer',
    value: function getAnalyzer() {
      return _analyzer2.default;
    }

    /**
     * Get the Stats Calculator singleton
     * @returns {StatsCalculator}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'getCalculator',
    value: function getCalculator() {
      return _calculator2.default;
    }
  }]);
  return Meetings;
}(_webexCore.WebexPlugin); /*!
                             * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
                           */

exports.default = Meetings;
//# sourceMappingURL=index.js.map
