'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _webexCore = require('@webex/webex-core');

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class MeetingRequest
 */
var MeetingRequest = function (_StatelessWebexPlugin) {
  (0, _inherits3.default)(MeetingRequest, _StatelessWebexPlugin);

  function MeetingRequest() {
    (0, _classCallCheck3.default)(this, MeetingRequest);
    return (0, _possibleConstructorReturn3.default)(this, (MeetingRequest.__proto__ || (0, _getPrototypeOf2.default)(MeetingRequest)).apply(this, arguments));
  }

  (0, _createClass3.default)(MeetingRequest, [{
    key: 'joinMeeting',

    /**
     * Make a network request to join a meeting
     * @param {Object} options
     * @param {String} options.sipUri
     * @param {String} options.deviceUrl
     * @param {String} options.locusUrl
     * @param {String} options.resourceId,
     * @param {String} options.correlationId
     * @returns {Promise}
     */
    value: function joinMeeting(options) {
      var sipUri = options.sipUri,
          deviceUrl = options.deviceUrl,
          locusUrl = options.locusUrl,
          resourceId = options.resourceId,
          correlationId = options.correlationId,
          ensureConversation = options.ensureConversation,
          moderator = options.moderator,
          hostPin = options.hostPin,
          moveToResource = options.moveToResource,
          roapMessage = options.roapMessage;


      var url = '';

      var body = {
        device: {
          url: deviceUrl,
          deviceType: this.config.meetings.deviceType
        },
        usingResource: resourceId || null,
        moveMediaToResource: resourceId && moveToResource || false,
        correlationId: correlationId,
        respOnlySdp: true,
        allowMultiDevice: true,
        ensureConversation: ensureConversation || false,
        supportsNativeLobby: 1
      };

      if (moderator !== undefined) {
        body.moderator = moderator;
      }

      if (hostPin !== undefined) {
        body.hostPIN = hostPin;
      }

      if (locusUrl) {
        url = locusUrl + '/' + _constants.PARTICIPANT;
      } else if (sipUri) {
        // eslint-lin-disable-next-line no-warning-comments
        // TODO switch to use the locus object and look into federation?
        url = this.webex.internal.device.services.locusServiceUrl + '/' + _constants.LOCI + '/' + _constants.CALL;
        body.invitee = {
          address: sipUri
        };
      }

      // TODO: -- this will be resolved in SDK request
      url = url.concat('?' + _constants.ALTERNATE_REDIRECT_TRUE);

      if (resourceId === sipUri) {
        body.callPreferences = {
          requestedMedia: [_constants._SLIDES_]
        };
      }

      if (roapMessage) {
        body.localMedias = roapMessage.localMedias;
      }

      return this.webex.request({
        method: _constants.HTTP_VERBS.POST,
        uri: url,
        body: body
      });
    }

    /**
     * Syns the missed delta event
     * @param {Object} options
     * @param {boolen} options.desync flag to get partial or whole locus object
     * @param {String} options.syncUrl sync url to get ht elatest locus delta
     * @returns {Promise}
     */

  }, {
    key: 'syncMeeting',
    value: function syncMeeting(options) {
      /* eslint-disable no-else-return */
      var desync = options.desync;
      var syncUrl = options.syncUrl;

      /* istanbul ignore else */

      if (desync) {
        // check for existing URL parameters
        syncUrl = syncUrl.concat(syncUrl.split('?')[1] ? '&' : '?').concat(_constants.LOCUS.SYNCDEBUG + '=' + desync);
      }

      return this.request({
        method: _constants.HTTP_VERBS.GET,
        uri: syncUrl
      }) // TODO: Handle if delta sync failed . Get the full locus object
      .catch(function (err) {
        _loggerProxy2.default.logger.error('MeetingRequest->syncMeeting#Error syncing meeting, error ' + err);

        return err;
      });
    }

    /**
     * Request to get the complete locus object
     * @param {Object} options
     * @param {boolen} options.desync flag to get partial or whole locus object
     * @param {String} options.locusUrl sync url to get ht elatest locus delta
     * @returns {Promise}
     */

  }, {
    key: 'getFullLocus',
    value: function getFullLocus(options) {
      var locusUrl = options.locusUrl;
      var desync = options.desync;


      if (locusUrl) {
        if (desync) {
          locusUrl += '?' + _constants.LOCUS.SYNCDEBUG + '=' + desync;
        }

        return this.request({
          method: _constants.HTTP_VERBS.GET,
          uri: locusUrl
        }).catch(function (err) {
          _loggerProxy2.default.logger.error('MeetingRequest->getFullLocus#Error getting full locus, error ' + err);

          return err;
        });
      }

      return _promise2.default.reject();
    }

    /**
     * Make a network request to leave a meeting
     * @param {Object} options
     * @param {String} options.deviceUrl
     * @param {String} options.resourceId,
     * @param {String} options.correlationId
     * @returns {Promise}
     */

  }, {
    key: 'leaveMeeting',
    value: function leaveMeeting(options) {
      var uri = options.locusUrl + '/' + _constants.PARTICIPANT + '/' + options.selfId + '/' + _constants.LEAVE;
      var body = {
        device: {
          deviceType: this.config.meetings.deviceType,
          url: options.deviceUrl
        },
        usingResource: options.resourceId || null,
        correlationId: options.correlationId
      };

      return this.request({
        method: _constants.HTTP_VERBS.PUT,
        uri: uri,
        body: body
      });
    }

    /**
     * Make a network request to acknowledge a meeting
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.id
     * @returns {Promise}
     */

  }, {
    key: 'acknowledgeMeeting',
    value: function acknowledgeMeeting(options) {
      var uri = options.locusUrl + '/' + _constants.PARTICIPANT + '/' + _constants.ALERT;
      var body = {
        device: {
          deviceType: this.config.meetings.deviceType,
          url: options.deviceUrl
        },
        correlationId: options.id
      };

      return this.request({
        method: _constants.HTTP_VERBS.PUT,
        uri: uri,
        body: body
      });
    }

    /**
     * Make a network request to acknowledge a meeting
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.id
     * @returns {Promise}
     */

  }, {
    key: 'recordMeeting',
    value: function recordMeeting(options) {
      var uri = options.locusUrl + '/' + _constants.CONTROLS;
      var body = {
        record: {
          recording: options.recording,
          paused: options.paused
        }
      };

      return this.request({
        method: _constants.HTTP_VERBS.PATCH,
        uri: uri,
        body: body
      });
    }
  }, {
    key: 'lockMeeting',
    value: function lockMeeting(options) {
      var uri = options.locusUrl + '/' + _constants.CONTROLS;
      var body = {
        lock: {
          locked: options.lock
        }
      };

      return this.request({
        method: _constants.HTTP_VERBS.PATCH,
        uri: uri,
        body: body
      });
    }

    /**
     * Make a network request to decline a meeting
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.reason
     * @returns {Promise}
     */

  }, {
    key: 'declineMeeting',
    value: function declineMeeting(options) {
      var uri = options.locusUrl + '/' + _constants.PARTICIPANT + '/' + _constants.DECLINE;
      var body = {
        device: {
          deviceType: this.config.meetings.deviceType,
          url: options.deviceUrl
        },
        reason: options.reason
      };

      return this.request({
        method: _constants.HTTP_VERBS.PUT,
        uri: uri,
        body: body
      });
    }

    /**
     * Toggle remote audio and/or video
     * @param {Object} options options for toggling
     * @param {String} options.selfId Locus self id??
     * @param {String} options.locusUrl Locus url
     * @param {String} options.deviceUrl Url of a device
     * @param {String} options.resourceId Populated if you are paired to a device
     * @param {String} options.localMedias local sdps
     * @returns {Promise}
     */

  }, {
    key: 'remoteAudioVideoToggle',
    value: function remoteAudioVideoToggle(options) {
      var uri = options.locusUrl + '/' + _constants.PARTICIPANT + '/' + options.selfId + '/' + _constants.MEDIA;
      var body = {
        device: {
          deviceType: this.config.meetings.deviceType,
          url: options.deviceUrl
        },
        usingResource: options.resourceId || null,
        correlationId: options.correlationId,
        respOnlySdp: true,
        localMedias: options.localMedias
      };

      return this.request({
        method: _constants.HTTP_VERBS.PUT,
        uri: uri,
        body: body
      });
    }

    /**
     * change the content floor grant
     * @param {Object} options options for floor grant
     * @param {String} options.disposition floor action (granted/released)
     * @param {String} options.personUrl personUrl who is requesting floor
     * @param {String} options.deviceUrl Url of a device
     * @param {String} options.resourceId Populated if you are paired to a device
     * @param {String} options.uri floor grant uri
     * @returns {Promise}
     */

  }, {
    key: 'changeMeetingFloor',
    value: function changeMeetingFloor(options) {
      var floorReq = { disposition: options.disposition };

      /* istanbul ignore else */
      if (options.disposition === _constants.FLOOR_ACTION.GRANTED) {
        floorReq = {
          beneficiary: {
            url: options.personUrl,
            devices: [{
              deviceType: this.config.meetings.deviceType,
              url: options.deviceUrl
            }]
          },
          disposition: options.disposition,
          requester: {
            url: options.personUrl
          }
        };
      }

      return this.request({
        uri: options.uri,
        method: _constants.HTTP_VERBS.PUT,
        body: {
          floor: floorReq,
          resourceUrl: options.resourceUrl
        }
      });
    }
  }]);
  return MeetingRequest;
}(_webexCore.StatelessWebexPlugin);

exports.default = MeetingRequest;
//# sourceMappingURL=request.js.map
