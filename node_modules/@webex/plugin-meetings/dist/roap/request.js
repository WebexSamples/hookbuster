'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _webexCore = require('@webex/webex-core');

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _constants = require('../constants');

var _metrics = require('../metrics');

var _metrics2 = _interopRequireDefault(_metrics);

var _config = require('../metrics/config');

var _parameter = require('../common/errors/parameter');

var _parameter2 = _interopRequireDefault(_parameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class RoapRequest
 */

/* global window */
var RoapRequest = function (_StatelessWebexPlugin) {
  (0, _inherits3.default)(RoapRequest, _StatelessWebexPlugin);

  function RoapRequest() {
    (0, _classCallCheck3.default)(this, RoapRequest);
    return (0, _possibleConstructorReturn3.default)(this, (RoapRequest.__proto__ || (0, _getPrototypeOf2.default)(RoapRequest)).apply(this, arguments));
  }

  (0, _createClass3.default)(RoapRequest, [{
    key: 'attachRechabilityData',

    /**
     * Joins a meeting via ROAP
     * @param {Object} options
     * @returns {Promise} returns a promise that resolves/rejects whatever the request does
     */

    value: function attachRechabilityData(localSdp) {
      var reachabilityData = window.localStorage.getItem(_constants.REACHABILITY.localStorage);

      if (reachabilityData) {
        try {
          var reachabilityResult = JSON.parse(reachabilityData);

          /* istanbul ignore else */
          if (reachabilityResult && (0, _keys2.default)(reachabilityResult).length) {
            localSdp.reachability = reachabilityResult;
          }
        } catch (e) {
          _loggerProxy2.default.logger.error('RoapRequest->attachReachabilityData#Error in parsing reachability data: ' + e);
        }
      }

      return localSdp;
    }
  }, {
    key: 'joinMeetingWithRoap',
    value: function joinMeetingWithRoap(options) {
      var _this2 = this;

      _loggerProxy2.default.logger.info('RoapRequest->joinMeetingWithRoap#Join locus with roap');
      _loggerProxy2.default.logger.info('RoapRequest->joinMeetingWithRoap#Clocal SDP: ' + options.roapMessage);

      return _promise2.default.resolve().then(function () {
        var deviceUrl = _this2.webex.internal.device.url;
        var url = '';

        var body = {
          deviceUrl: deviceUrl,
          usingResource: options.resourceId || null,
          correlationId: options.correlationId,
          localMedias: [{
            localSdp: (0, _stringify2.default)(_this2.attachRechabilityData({
              roapMessage: options.roapMessage,
              audioMuted: false,
              videoMuted: false
            }))
          }]
        };

        if (options.locusUrl) {
          url = options.locusUrl + '/' + _constants.PARTICIPANT;
        } else if (options.sipUrl) {
          url = _this2.webex.internal.device.services.locusServiceUrl + '/' + _constants.LOCI + '/' + _constants.CALL;
          body.invitee = {
            address: options.sipTarget
          };
        } else {
          throw new _parameter2.default('Must provide a locusUrl or sipTarget');
        }

        return _this2.webex.request({
          method: _constants.HTTP_VERBS.POST,
          uri: url,
          body: body
        }).then(function (res) {
          var locus = res.body.locus;


          locus.roapSeq = options.roapMessage.seq;
          locus.id = locus.url.split('/').pop();
          _loggerProxy2.default.logger.info('RoapRequest->joinMeetingWithRoap#Joined locus [' + locus.id + '][' + locus.fullState.lastActive + ']');

          return locus;
        }).catch(function (err) {
          _loggerProxy2.default.logger.error('RoapRequest->joinMeetingWithRoap#failed with error: ' + err);
          throw err;
        });
      });
    }

    /**
     * Sends a ROAP message
     * @param {Object} options
     * @param {String} options.roapMessage
     * @param {String} options.locusId
     * @param {String} options.locusSelfId
     * @param {String} options.mediaId
     * @param {String} options.correlationId
     * @returns {Promise} returns the response/failure of the request
     */

  }, {
    key: 'sendRoap',
    value: function sendRoap(options) {
      var roapMessage = options.roapMessage,
          locusSelfUrl = options.locusSelfUrl,
          mediaId = options.mediaId,
          correlationId = options.correlationId,
          meetingId = options.meetingId;


      if (!mediaId) {
        _loggerProxy2.default.logger.info('RoapRequest->sendRoap#Race Condition /call mediaID not present');
      }

      var mediaUrl = locusSelfUrl + '/' + _constants.MEDIA;
      var deviceUrl = this.webex.internal.device.url;

      _loggerProxy2.default.logger.info('RoapRequest->sendRoap#' + mediaUrl + ' \n ' + roapMessage.messageType + ' \n seq:' + roapMessage.seq);

      _metrics2.default.postEvent({ event: _config.eventType.MEDIA_REQUEST, meetingId: meetingId });

      return this.webex.request({
        uri: mediaUrl,
        method: _constants.HTTP_VERBS.PUT,
        body: {
          device: {
            url: deviceUrl,
            deviceType: this.config.meetings.deviceType
          },
          correlationId: correlationId,
          localMedias: [{
            localSdp: (0, _stringify2.default)(this.attachRechabilityData({
              roapMessage: roapMessage,
              // eslint-disable-next-line no-warning-comments
              // TODO: check whats the need for video and audiomute
              audioMuted: !!options.audioMuted,
              videoMuted: !!options.audioVideo
            })),
            mediaId: options.mediaId
          }]
        }
      }).then(function (res) {
        _metrics2.default.postEvent({ event: _config.eventType.MEDIA_RESPONSE, meetingId: meetingId });

        // always it will be the first mediaConnection Object
        var mediaConnection = res.body.mediaConnections && res.body.mediaConnections.length > 0 && res.body.mediaConnections[0];

        _loggerProxy2.default.logger.info('RoapRequest->sendRoap#:response:' + (0, _stringify2.default)(mediaConnection, null, 2) + '\'\n StatusCode:\'' + res.statusCode);
        var locus = res.body.locus;


        locus.roapSeq = options.roapMessage.seq;

        return locus;
      }).catch(function (err) {
        _metrics2.default.postEvent({ event: _config.eventType.MEDIA_RESPONSE, meetingId: meetingId, data: { error: _metrics2.default.parseLocusError(err, true) } });
        _loggerProxy2.default.logger.error('RoapRequest->sendRoap#Error:' + (0, _stringify2.default)(err, null, 2));
        _loggerProxy2.default.logger.error('RoapRequest->sendRoapRequest#errorBody:' + (0, _stringify2.default)(roapMessage, null, 2) + ' + \'\\n mediaId:\'' + options.mediaId);
        throw err;
      });
    }
  }]);
  return RoapRequest;
}(_webexCore.StatelessWebexPlugin);

exports.default = RoapRequest;
//# sourceMappingURL=request.js.map
