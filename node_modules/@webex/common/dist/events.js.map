{"version":3,"sources":["events.js"],"names":["proxyEvents","transferEvents","emitter","proxy","forEach","key","events","source","drain","event","on","args","emit","target","method","trigger","Error","rest"],"mappings":";;;;;;;;;;;;;;QAYgBA,W,GAAAA,W;QAsBAC,c,GAAAA,c;;;;AA5BhB;;;;;;AANA;;;;AAYO,SAASD,WAAT,CAAqBE,OAArB,EAA8BC,KAA9B,EAAqC;AAC1C,GACE,IADF,EAEE,MAFF,EAGEC,OAHF,CAGU,UAACC,GAAD,EAAS;AACjBF,UAAME,GAAN,IAAa,YAAa;AACxBH,cAAQG,GAAR;;AAEA,aAAOF,KAAP;AACD,KAJD;AAKD,GATD;;AAWA,SAAOD,OAAP;AACD;;AAED;;;;;;;AAOO,SAASD,cAAT,CAAwBK,MAAxB,EAAgCC,MAAhC,EAAwCC,KAAxC,EAA+C;AACpDF,WAAS,uBAAQA,MAAR,IAAkBA,MAAlB,GAA2B,CAACA,MAAD,CAApC;AACAA,SAAOF,OAAP,CAAe,UAACK,KAAD,EAAW;AACxB,QAAIF,OAAOG,EAAX,EAAe;AACbH,aAAOG,EAAP,CAAUD,KAAV,EAAiB;AAAA,0CAAIE,IAAJ;AAAIA,cAAJ;AAAA;;AAAA,eAAaC,uBAAKJ,KAAL,EAAYC,KAAZ,SAAsBE,IAAtB,EAAb;AAAA,OAAjB;AACD;AACF,GAJD;AAKD;;AAED;;;;;AAKA,SAASC,IAAT,CAAcC,MAAd,EAA+B;AAC7B,MAAMC,SAASD,OAAOE,OAAP,IAAkBF,OAAOD,IAAxC;;AAEA;AACA,MAAI,CAACE,MAAL,EAAa;AACX,UAAM,IAAIE,KAAJ,CAAU,iCAAV,CAAN;AACD;;AAN4B,qCAANC,IAAM;AAANA,QAAM;AAAA;;AAQ7B,SAAO,qBAAcH,MAAd,EAAsBD,MAAtB,EAA8BI,IAA9B,CAAP;AACD","file":"events.js","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {isArray} from 'lodash';\n\n/**\n * Proxies the event binding methods of emitter onto proxy\n * @param {EventEmitter|EventEmitterProxy} emitter\n * @param {mixed} proxy (probably a promise)\n * @returns {EventEmitter} Returns the source emitter to ease use in promise chains\n */\nexport function proxyEvents(emitter, proxy) {\n  [\n    'on',\n    'once'\n  ].forEach((key) => {\n    proxy[key] = (...args) => {\n      emitter[key](...args);\n\n      return proxy;\n    };\n  });\n\n  return emitter;\n}\n\n/**\n * Given a list of events, fires them on drain when they're emitted from source\n * @param {Array|string} events\n * @param {EventEmitter} source\n * @param {EventEmitter} drain\n * @returns {undefined}\n */\nexport function transferEvents(events, source, drain) {\n  events = isArray(events) ? events : [events];\n  events.forEach((event) => {\n    if (source.on) {\n      source.on(event, (...args) => emit(drain, event, ...args));\n    }\n  });\n}\n\n/**\n * Emits an event\n * @param {EventEmitter} target The EventEmitter from which to emit an event\n * @returns {mixed}\n */\nfunction emit(target, ...rest) {\n  const method = target.trigger || target.emit;\n\n  /* istanbul ignore if */\n  if (!method) {\n    throw new Error('count not determine emit method');\n  }\n\n  return Reflect.apply(method, target, rest);\n}\n"]}