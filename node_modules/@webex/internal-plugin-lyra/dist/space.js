'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _webexCore = require('@webex/webex-core');

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _common = require('@webex/common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * @extends {Lyra}
 * @memberof Lyra
 */
var Space = _webexCore.WebexPlugin.extend({
  namespace: 'Lyra',

  /**
   * Lists lyra spaces associated with user
   *
   * @returns {Promise<Array>} spaces
   */
  list: function list() {
    return this.webex.request({
      method: 'GET',
      api: 'lyra',
      resource: '/spaces'
    }).then(function (res) {
      return res.body.items;
    });
  },


  /**
   * Retrieves a lyra space info
   * @param {Types~LyraSpace} space
   * @param {string} space.id
   * @param {string} space.identity.id
   * @returns {Promise<LyraSpace>} response body
   */
  get: function get() {
    var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var spaceId = space.id || space.identity && space.identity.id;

    if (!spaceId) {
      return _promise2.default.reject(new Error('space.id is required'));
    }

    return this.webex.request({
      method: 'GET',
      api: 'lyra',
      resource: '/spaces/' + spaceId
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Joins a lyra space, update every 10 minutes to keep alive for MANUAL
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @param {object} options
   * @param {string} options.passType
   * @param {string} options.data additional data such as proof for ultrasound
   * @param {string} options.uri use a custom uri
   * @returns {Promise}
   */
  join: function join(space, options) {
    options = (0, _assign2.default)({
      passType: 'MANUAL'
    }, options);

    var body = {
      pass: {
        type: options.passType
      },
      deviceUrl: this.webex.internal.device.url
    };

    if (options.data) {
      body.pass.data = options.data;
    }

    if (options.verificationInitiation) {
      body.verificationInitiation = options.verificationInitiation;
    }

    // if options.uri is available use it, since that would have the
    // complete lyra service URL
    if (options.uri) {
      return this.webex.request({
        method: 'PUT',
        uri: options.uri,
        body: body
      });
    }

    return this.webex.request({
      method: 'PUT',
      api: 'lyra',
      resource: space.url + '/occupants/@me',
      body: body
    });
  },


  /**
   * Leaves a lyra space
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @param {object} options
   * @param {boolean} options.removeAllDevices remove all devices of current user also
   * @returns {Promise}
   */
  leave: function leave(space) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    // all devices are removed by default (when deviceUrl is not supplied)
    var uri = space.url + '/occupants/@me';

    if (!options.removeAllDevices) {
      var params = {
        deviceUrl: _common.base64.toBase64Url(this.webex.internal.device.url)
      };

      uri += '?' + _querystring2.default.stringify(params);
    }

    return this.webex.request({
      method: 'DELETE',
      api: 'lyra',
      resource: uri
    });
  },


  /**
   * Verifies a space occupant (to be used by the lyra device)
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @param {string} occupantId id of user to verify
   * @returns {Promise}
   */
  verifyOccupant: function verifyOccupant(space, occupantId) {
    var body = {
      pass: {
        type: 'VERIFICATION'
      }
    };

    return this.webex.request({
      method: 'PUT',
      uri: space.url + '/occupants/' + occupantId,
      body: body
    });
  },


  /**
   * Gets the state of bindings in this Lyra space
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @returns {Promise<LyraBindings>} bindings response body
   */
  getCurrentBindings: function getCurrentBindings(space) {
    return this.webex.request({
      method: 'GET',
      uri: space.url + '/bindings'
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Binds a conversation to lyra space
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @param {string} space.id
   * @param {string} space.identity.id
   * @param {Types~Conversation} conversation
   * @param {string} conversation.kmsResourceObjectUrl
   * @param {string} conversation.url
   * @param {object} options
   * @param {boolean} options.uri complete lyra service URL
   * @returns {Promise<LyraBindings>} bindings response body
   */
  bindConversation: function bindConversation() {
    var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _this = this;

    var conversation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var spaceId = space.id || space.identity && space.identity.id;

    if (!space.url) {
      return _promise2.default.reject(new Error('space.url is required'));
    }

    if (!spaceId) {
      return _promise2.default.reject(new Error('space.id is required'));
    }

    if (!conversation.kmsResourceObjectUrl) {
      return _promise2.default.reject(new Error('conversation.kmsResourceObjectUrl is required'));
    }

    if (!conversation.url) {
      return _promise2.default.reject(new Error('conversation.url is required'));
    }

    var body = {
      kmsMessage: {
        method: 'create',
        uri: '/authorizations',
        resourceUri: '' + conversation.kmsResourceObjectUrl,
        userIds: [spaceId]
      },
      conversationUrl: conversation.url
    };

    var request = {
      method: 'POST',
      body: body
    };

    // if options.uri is available use it, since that would have the
    // complete lyra service URL
    if (options.uri) {
      request.uri = options.uri;
    } else {
      request.api = 'lyra';
      request.resource = space.url + '/bindings';
    }

    return this._bindConversation(spaceId).then(function () {
      return _this.webex.request(request);
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Binds a conversation to lyra space by posting capabilities to Lyra.
   *
   * Lyra no longer automatically enables binding for a space containing a device with type "SPARK_BOARD".
   * Webexboard now is running the CE code stack which supports posting of capabilities to Lyra.
   * @param {String} spaceId space ID
   * @returns {Promise<LyraBindings>} bindings response body
   */
  _bindConversation: function _bindConversation(spaceId) {
    // Skip until we can bind a conversation to lyra space by posting capabilities to Lyra.
    /* eslint no-unreachable: 1 */
    return _promise2.default.resolve();

    // PUT /lyra/api/v1/spaces/{spaceId}/devices/{encodedDeviceUrl}/capabilities
    var encodedDeviceUrl = _common.base64.encode(this.webex.internal.device.url);
    var resource = 'spaces/' + spaceId + '/devices/' + encodedDeviceUrl + '/capabilities';

    return this.webex.request({
      method: 'PUT',
      api: 'lyra',
      resource: resource,
      body: {
        bindingCleanupAfterCall: true
      }
    });
  },


  /**
   * Removes binding between a conversation and a lyra space using conversation
   * url
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @param {string} space.id
   * @param {string} space.identity.id
   * @param {Types~Conversation} conversation
   * @param {string} conversation.kmsResourceObjectUrl
   * @param {string} conversation.url
   * @param {object} options
   * @param {boolean} options.uri complete lyra service URL
   * @returns {Promise<LyraBindings>} bindings response body
   */
  unbindConversation: function unbindConversation() {
    var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _this2 = this;

    var conversation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var spaceId = space.id || space.identity && space.identity.id;

    if (!space.url) {
      return _promise2.default.reject(new Error('space.url is required'));
    }

    if (!spaceId) {
      return _promise2.default.reject(new Error('space.id is required'));
    }

    if (!conversation.url) {
      return _promise2.default.reject(new Error('conversation.url is required'));
    }

    if (!conversation.kmsResourceObjectUrl) {
      return _promise2.default.reject(new Error('conversation.kmsResourceObjectUrl is required'));
    }

    var parameters = {
      kmsMessage: {
        method: 'delete',
        uri: conversation.kmsResourceObjectUrl + '/authorizations?' + _querystring2.default.stringify({ authId: spaceId })
      },
      conversationUrl: _common.base64.toBase64Url(conversation.url)
    };

    return this.webex.internal.encryption.kms.prepareRequest(parameters.kmsMessage).then(function (req) {
      parameters.kmsMessage = req.wrapped;
      // if options.uri is available use it, since that would have the
      // complete lyra service URL
      if (options.uri) {
        return _this2.webex.request({
          method: 'DELETE',
          uri: options.uri + '?' + _querystring2.default.stringify(parameters)
        });
      }

      return _this2.webex.request({
        method: 'DELETE',
        api: 'lyra',
        resource: space.url + '/bindings?' + _querystring2.default.stringify(parameters)
      });
    });
  },


  /**
   * Delete a binding using binding id
   * @param {Types~LyraSpace} space
   * @param {string} space.url
   * @param {string} space.identity.id
   * @param {object} options
   * @param {string} options.kmsResourceObjectUrl
   * @param {string} options.bindingId
   * @returns {Promise<LyraBindings>} bindings response body
   */
  deleteBinding: function deleteBinding() {
    var _this3 = this;

    var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var spaceId = space.id || space.identity && space.identity.id;

    if (!space.url) {
      return _promise2.default.reject(new Error('space.url is required'));
    }

    if (!spaceId) {
      return _promise2.default.reject(new Error('space.id is required'));
    }

    if (!options.kmsResourceObjectUrl) {
      return _promise2.default.reject(new Error('options.kmsResourceObjectUrl is required'));
    }

    if (!options.bindingId) {
      return _promise2.default.reject(new Error('options.bindingId is required'));
    }

    var parameters = {
      kmsMessage: {
        method: 'delete',
        uri: options.kmsResourceObjectUrl + '/authorizations?' + _querystring2.default.stringify({ authId: spaceId })
      }
    };

    return this.webex.internal.encryption.kms.prepareRequest(parameters.kmsMessage).then(function (req) {
      parameters.kmsMessage = req.wrapped;

      return _this3.webex.request({
        method: 'DELETE',
        uri: space.url + '/bindings/' + options.bindingId + '?' + _querystring2.default.stringify(parameters)
      });
    });
  },
  version: '1.72.6'
}); /*!
     * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
     */

exports.default = Space;
//# sourceMappingURL=space.js.map
