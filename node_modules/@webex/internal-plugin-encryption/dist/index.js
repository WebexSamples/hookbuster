'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DryError = exports.KmsError = exports.KMS = exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _encryption = require('./encryption');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_encryption).default;
  }
});

var _kms = require('./kms');

Object.defineProperty(exports, 'KMS', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_kms).default;
  }
});

var _kmsErrors = require('./kms-errors');

Object.defineProperty(exports, 'KmsError', {
  enumerable: true,
  get: function get() {
    return _kmsErrors.KmsError;
  }
});
Object.defineProperty(exports, 'DryError', {
  enumerable: true,
  get: function get() {
    return _kmsErrors.DryError;
  }
});

var _webexCore = require('@webex/webex-core');

var _encryption2 = _interopRequireDefault(_encryption);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

require('@webex/internal-plugin-wdm');

require('@webex/internal-plugin-mercury');

var _kmsDryErrorInterceptor = require('./kms-dry-error-interceptor');

var _kmsDryErrorInterceptor2 = _interopRequireDefault(_kmsDryErrorInterceptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var interceptors = void 0; /*!
                            * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
                            */

// Note: There's a bug where if bind gets replayed because of a timeout in which
// the original request eventually completed, there'll be an error indicating
// the key can't be bound (because it already has been). This could be mitigated
// by using Promise.race to resolve replays (as more requests get enqueue for a
// specific action, accept whichever one completes first).

if (process.env.NODE_ENV === 'test') {
  interceptors = {
    KmsDryErrorInterceptor: _kmsDryErrorInterceptor2.default.create
  };
}

(0, _webexCore.registerInternalPlugin)('encryption', _encryption2.default, {
  payloadTransformer: {
    predicates: [{
      name: 'encryptKmsMessage',
      direction: 'outbound',
      // I don't see any practical way to reduce complexity here.
      // eslint-disable-next-line complexity
      test: function test(ctx, options) {
        if (!(0, _has3.default)(options, 'body.kmsMessage')) {
          return _promise2.default.resolve(false);
        }

        if (!(0, _isObject3.default)(options.body.kmsMessage)) {
          return _promise2.default.resolve(false);
        }

        // If this is a template for a kms message, assume another transform
        // will fill it in later. This is a bit of a leaky abstraction, but the
        // alternative is building a complex rules engine for controlling
        // ordering of transforms
        if (options.body.kmsMessage.keyUris && options.body.kmsMessage.keyUris.length === 0) {
          return _promise2.default.resolve(false);
        }
        if (options.body.kmsMessage.resourceUri && (options.body.kmsMessage.resourceUri.includes('<KRO>') || options.body.kmsMessage.resourceUri.includes('<KEYURL>'))) {
          return _promise2.default.resolve(false);
        }
        if (options.body.kmsMessage.uri && (options.body.kmsMessage.uri.includes('<KRO>') || options.body.kmsMessage.uri.includes('<KEYURL>'))) {
          return _promise2.default.resolve(false);
        }

        return _promise2.default.resolve(true);
      },
      extract: function extract(options) {
        return _promise2.default.resolve(options.body);
      }
    }, {
      name: 'decryptKmsMessage',
      direction: 'inbound',
      test: function test(ctx, response) {
        return _promise2.default.resolve((0, _has3.default)(response, 'body.kmsMessage') && (0, _isString3.default)(response.body.kmsMessage));
      },
      extract: function extract(response) {
        return _promise2.default.resolve(response.body);
      }
    }, {
      name: 'decryptErrorResponse',
      direction: 'inbound',
      test: function test(ctx, reason) {
        return _promise2.default.resolve(Boolean(reason.body && reason.body.errorCode === 1900000));
      },
      extract: function extract(reason) {
        return _promise2.default.resolve(reason);
      }
    }],
    transforms: [{
      name: 'encryptKmsMessage',
      fn: function fn(ctx, object) {
        if (!object) {
          return _promise2.default.resolve();
        }

        if (!object.kmsMessage) {
          return _promise2.default.resolve();
        }

        if ((0, _isString3.default)(object.kmsMessage)) {
          return _promise2.default.resolve();
        }

        return ctx.webex.internal.encryption.kms.prepareRequest(object.kmsMessage).then(function (req) {
          object.kmsMessage = req.wrapped;
        });
      }
    }, {
      name: 'decryptKmsMessage',
      fn: function fn(ctx, object) {
        return ctx.webex.internal.encryption.kms.decryptKmsMessage(object.kmsMessage).then(function (kmsMessage) {
          object.kmsMessage = kmsMessage;
        });
      }
    }, {
      name: 'decryptErrorResponse',
      fn: function fn(ctx, reason) {
        var promises = reason.body.errors.map(function (error) {
          return ctx.webex.internal.encryption.kms.decryptKmsMessage(error.description).then(function (desc) {
            error.description = desc;
          });
        });

        promises.push(ctx.webex.internal.encryption.kms.decryptKmsMessage(reason.body.message).then(function (kmsMessage) {
          reason.body.message = kmsMessage;
        }));

        return _promise2.default.all(promises).then(function () {
          return _promise2.default.reject(new _kmsErrors.DryError(reason));
        });
      }
    }]
  },
  interceptors: interceptors,
  config: _config2.default
});
//# sourceMappingURL=index.js.map
