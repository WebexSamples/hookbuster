'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _uniq2 = require('lodash/uniq');

var _uniq3 = _interopRequireDefault(_uniq2);

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _merge2 = require('lodash/merge');

var _merge3 = _interopRequireDefault(_merge2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _events = require('events');

var _common = require('@webex/common');

var _webexCore = require('@webex/webex-core');

var _helperImage = require('@webex/helper-image');

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _convoError = require('./convo-error');

var _shareActivity = require('./share-activity');

var _shareActivity2 = _interopRequireDefault(_shareActivity);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

var Conversation = _webexCore.WebexPlugin.extend({
  namespace: 'Conversation',

  acknowledge: function acknowledge(conversation, object, activity) {
    var _this = this;

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    return this._inferConversationUrl(conversation).then(function () {
      return _this.prepare(activity, {
        verb: 'acknowledge',
        target: _this.prepareConversation(conversation),
        object: {
          objectType: 'activity',
          id: object.id,
          url: object.url
        }
      });
    }).then(function (a) {
      return _this.submit(a);
    });
  },


  /**
   * Adds a participant to a conversation
   * @param {Object} conversation
   * @param {Object|string} participant
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  add: function add(conversation, participant, activity) {
    var _this2 = this;

    return this._inferConversationUrl(conversation).then(function () {
      return _this2.webex.internal.user.asUUID(participant, { create: true });
    }).then(function (id) {
      return _this2.prepare(activity, {
        verb: 'add',
        target: _this2.prepareConversation(conversation),
        object: {
          id: id,
          objectType: 'person'
        },
        kmsMessage: {
          method: 'create',
          uri: '/authorizations',
          resourceUri: '<KRO>',
          userIds: [id]
        }
      }).then(function (a) {
        return _this2.submit(a);
      });
    });
  },


  /**
   * Creates a conversation
   * @param {Object} params
   * @param {Array<Participant>} params.participants
   * @param {Array<File>} params.files
   * @param {string} params.comment
   * @param {string} params.html
   * @param {Object} params.displayName
   * @param {Object} options
   * @param {Boolean} options.allowPartialCreation
   * @param {Boolean} options.forceGrouped
   * @param {Boolean} options.skipOneOnOneFetch skips checking 1:1 exists before creating conversation
   * @returns {Promise<Conversation>}
   */
  create: function create(params, options) {
    var _this3 = this;

    options = options || {};

    if (!params.participants || params.participants.length === 0) {
      return _promise2.default.reject(new Error('`params.participants` is required'));
    }

    return _promise2.default.all(params.participants.map(function (participant) {
      return _this3.webex.internal.user.asUUID(participant, { create: true })
      // eslint-disable-next-line arrow-body-style
      .catch(function (err) {
        return options.allowPartialCreation ? undefined : _promise2.default.reject(err);
      });
    })).then(function (participants) {
      participants.unshift(_this3.webex.internal.device.userId);
      participants = (0, _uniq3.default)(participants);

      var validParticipants = participants.filter(function (participant) {
        return participant;
      });

      params.participants = validParticipants;

      // check if original participants list was to create a 1:1
      if (participants.length === 2 && !(options && options.forceGrouped)) {
        if (!params.participants[1]) {
          return _promise2.default.reject(new _convoError.InvalidUserCreation());
        }

        if (options.skipOneOnOneFetch) {
          return _this3._createOneOnOne(params);
        }

        return _this3._maybeCreateOneOnOneThenPost(params, options);
      }

      return _this3._createGrouped(params, options);
    }).then(function (c) {
      if (!params.files) {
        return c;
      }

      return _this3.webex.internal.conversation.share(c, params.files).then(function (a) {
        c.activities.items.push(a);

        return c;
      });
    });
  },
  delete: function _delete(conversation, object, activity) {
    var _this4 = this;

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    return this._inferConversationUrl(conversation).then(function () {
      return _this4.prepare(activity, {
        verb: 'delete',
        target: _this4.prepareConversation(conversation),
        object: (0, _pick3.default)(object, 'id', 'url', 'objectType')
      });
    }).then(function (a) {
      return _this4.submit(a);
    });
  },


  /**
   * Downloads the file specified in item.scr or item.url
   * @param {Object} item
   * @param {Object} item.scr
   * @param {string} item.url
   * @param {Object} options
   * @param {Object} options.headers
   * @returns {Promise<File>}
   */
  download: function download(item, options) {
    var _this5 = this;

    var isEncrypted = Boolean(item.scr && item.scr.key);
    var shunt = new _events.EventEmitter();
    var promise = void 0;

    if (isEncrypted) {
      promise = this.webex.internal.encryption.download(item.scr);
    } else if (item.scr && item.scr.loc) {
      promise = this._downloadUnencryptedFile(item.scr.loc, options);
    } else {
      promise = this._downloadUnencryptedFile(item.url, options);
    }

    promise = promise.on('progress', function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return shunt.emit.apply(shunt, ['progress'].concat(args));
    }).then(function (res) {
      return (0, _helperImage.readExifData)(item, res);
    }).then(function (file) {
      _this5.logger.info('conversation: file downloaded');

      if (item.displayName && !file.name) {
        file.name = item.displayName;
      }

      if (!file.type && item.mimeType) {
        file.type = item.mimeType;
      }

      return file;
    });

    (0, _common.proxyEvents)(shunt, promise);

    return promise;
  },


  /**
   * Downloads an unencrypted file
   * @param {string} uri
   * @param {Object} options
   * @param {Ojbect} options.headers
   * @returns {Promise<File>}
   */
  _downloadUnencryptedFile: function _downloadUnencryptedFile(uri, options) {
    options = options || {};
    (0, _assign2.default)(options, {
      uri: uri,
      responseType: 'buffer'
    });

    var promise = this.request(options).then(function (res) {
      return res.body;
    });

    (0, _common.proxyEvents)(options.download, promise);

    return promise;
  },


  /**
   * Helper method that expands a set of parameters into an activty object
   * @param {string} verb
   * @param {Object} object
   * @param {Object} target
   * @param {Object|string} actor
   * @returns {Object}
   */
  expand: function expand(verb, object, target, actor) {
    var activity = {
      actor: actor,
      objectType: 'activity',
      verb: verb
    };

    if (!actor) {
      actor = this.webex.internal.device.userId;
    }

    if ((0, _isString3.default)(actor)) {
      activity.actor = {
        objectType: 'person',
        id: actor
      };
    }

    if (object) {
      activity.object = object;
    }

    if (target) {
      activity.target = target;
    }

    return activity;
  },


  /**
   * Fetches a single conversation
   * @param {Object} conversation
   * @param {Object} options
   * @returns {Promise<Conversation>}
   */
  get: function get(conversation, options) {
    var _this6 = this;

    return this._inferConversationUrl(conversation).then(function () {
      var user = conversation.user,
          url = conversation.url;


      options = options || {};

      var params = {
        qs: (0, _assign2.default)({
          uuidEntryFormat: true,
          personRefresh: true,
          activitiesLimit: 0,
          includeConvWithDeletedUserUUID: false,
          includeParticipants: false
        }, (0, _omit3.default)(options, 'id', 'user', 'url'))
      };

      // Default behavior is to set includeParticipants=false,
      // which makes the payload lighter by removing participant info.
      // If the caller explicitly sets the participantAckFilter or
      // participantsLimit, we don't want that default setting.
      if ('participantAckFilter' in options || 'participantsLimit' in options) {
        delete params.qs.includeParticipants;
      }

      return _promise2.default.resolve(user ? _this6.webex.internal.user.asUUID(user) : null).then(function (userId) {
        if (userId) {
          (0, _assign2.default)(params, {
            service: 'conversation',
            resource: 'conversations/user/' + userId
          });
        } else {
          params.uri = url;
        }

        return _this6.request(params);
      });
    }).then((0, _common.tap)(function (res) {
      return _this6._recordUUIDs(res.body);
    })).then(function (res) {
      return res.body;
    });
  },


  /**
   * Leaves the conversation or removes the specified user from the specified
   * conversation
   * @param {Object} conversation
   * @param {Object|string} participant If not specified, defaults to current
   * user
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  leave: function leave(conversation, participant, activity) {
    var _this7 = this;

    return this._inferConversationUrl(conversation).then(function () {
      if (!participant) {
        participant = _this7.webex.internal.device.userId;
      }

      return _this7.webex.internal.user.asUUID(participant).then(function (id) {
        return _this7.prepare(activity, {
          verb: 'leave',
          target: _this7.prepareConversation(conversation),
          object: {
            id: id,
            objectType: 'person'
          },
          kmsMessage: {
            method: 'delete',
            uri: '<KRO>/authorizations?' + _querystring2.default.stringify({ authId: id })
          }
        });
      });
    }).then(function (a) {
      return _this7.submit(a);
    });
  },


  /**
   * Lists a set of conversations. By default does not fetch activities or
   * participants
   * @param {Object} options
   * @param {boolean} options.deferDecrypt - when true, deferDecrypt tells the
   * payload transformer to normalize (but not decrypt) each received
   * conversation. Instead, the received conversations will each have a bound
   * decrypt method that can be executed at the consumer's leisure
   * @returns {Promise<Array<Conversation>>}
   */
  list: function list(options) {
    return this._list({
      service: 'conversation',
      resource: 'conversations',
      qs: (0, _omit3.default)(options, 'deferDecrypt'),
      deferDecrypt: options.deferDecrypt
    });
  },


  /**
   * Lists the conversations the current user has left. By default does not
   * fetch activities or participants
   * @param {Object} options
   * @returns {Promise<Array<Conversation>>}
   */
  listLeft: function listLeft(options) {
    return this._list({
      service: 'conversation',
      resource: 'conversations/left',
      qs: options
    });
  },


  /**
   * List activities for the specified conversation
   * @param {Object} options
   * @returns {Promise<Array<Activity>>}
   */
  listActivities: function listActivities(options) {
    return this._listActivities((0, _assign2.default)(options, { mentions: false }));
  },


  /**
   * Lists activities in which the current user was mentioned
   * @param {Object} options
   * @returns {Promise<Array<Activity>>}
   */
  listMentions: function listMentions(options) {
    return this._listActivities((0, _assign2.default)(options, { mentions: true }));
  },


  /**
   * Mutes the mentions of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  muteMentions: function muteMentions(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_OFF']
    }, activity);
  },


  /**
   * Mutes the messages of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  muteMessages: function muteMessages(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MESSAGE_NOTIFICATIONS_OFF']
    }, activity);
  },
  cardAction: function cardAction(conversation, inputs, parentActivity) {
    var _this8 = this;

    var activity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    activity.parent = {
      id: parentActivity.id,
      type: 'cardAction'
    };

    return this._inferConversationUrl(conversation).then(function () {
      return _this8.prepare(activity, {
        verb: 'cardAction',
        target: _this8.prepareConversation(conversation),
        object: (0, _assign2.default)({ objectType: 'submit' }, inputs)
      });
    }).then(function (a) {
      return _this8.submit(a);
    });
  },


  /**
   * Posts a message to a conversation
   * @param {Object} conversation
   * @param {Object|string} message if string, treated as plaintext; if object,
   * assumed to be object property of `post` activity
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  post: function post(conversation, message, activity) {
    var _this9 = this;

    if ((0, _isString3.default)(message)) {
      message = {
        displayName: message
      };
    }

    return this._inferConversationUrl(conversation).then(function () {
      return _this9.prepare(activity, {
        verb: 'post',
        target: _this9.prepareConversation(conversation),
        object: (0, _assign2.default)({ objectType: 'comment' }, message)
      });
    }).then(function (a) {
      return _this9.submit(a);
    });
  },
  prepareConversation: function prepareConversation(conversation) {
    return (0, _defaults3.default)((0, _pick3.default)(conversation, 'id', 'url', 'objectType', 'defaultActivityEncryptionKeyUrl', 'kmsResourceObjectUrl'), {
      objectType: 'conversation'
    });
  },
  prepare: function prepare(activity, params) {
    var _this10 = this;

    params = params || {};
    activity = activity || {};

    return _promise2.default.resolve(activity.prepare ? activity.prepare(params) : activity).then(function (act) {
      (0, _defaults3.default)(act, {
        verb: params.verb,
        kmsMessage: params.kmsMessage,
        objectType: 'activity',
        clientTempId: _uuid2.default.v4(),
        actor: _this10.webex.internal.device.userId
      });

      // Workaround because parent is a reserved props in Ampersand
      if (activity.parentActivityId && activity.activityType || activity.parent && activity.parent.id && activity.parent.type) {
        act.parent = {
          id: activity.parentActivityId || activity.parent.id,
          type: activity.activityType || activity.parent.type
        };
      }

      if ((0, _isString3.default)(act.actor)) {
        act.actor = {
          objectType: 'person',
          id: act.actor
        };
      }

      ['actor', 'object'].forEach(function (key) {
        if (params[key]) {
          act[key] = act[key] || {};
          (0, _defaults3.default)(act[key], params[key]);
        }
      });

      if (params.target) {
        (0, _merge3.default)(act, {
          target: (0, _pick3.default)(params.target, 'id', 'url', 'objectType', 'kmsResourceObjectUrl', 'defaultActivityEncryptionKeyUrl')
        });
      }

      ['object', 'target'].forEach(function (key) {
        if (act[key] && act[key].url && !act[key].id) {
          act[key].id = act[key].url.split('/').pop();
        }
      });

      ['actor', 'object', 'target'].forEach(function (key) {
        if (act[key] && !act[key].objectType) {
          // Reminder: throwing here because it's the only way to get out of
          // this loop in event of an error.
          throw new Error('`act.' + key + '.objectType` must be defined');
        }
      });

      if (act.object && act.object.content && !act.object.displayName) {
        return _promise2.default.reject(new Error('Cannot submit activity object with `content` but no `displayName`'));
      }

      return act;
    });
  },


  /**
   * Handles incoming conversation.activity mercury messages
   * @param {Event} event
   * @returns {Promise}
   */
  processActivityEvent: function processActivityEvent(event) {
    return this.webex.transform('inbound', event).then(function () {
      return event;
    });
  },


  /**
   * Removes all mute-related tags
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  removeAllMuteTags: function removeAllMuteTags(conversation, activity) {
    return this.untag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_OFF', 'MENTION_NOTIFICATIONS_ON', 'MESSAGE_NOTIFICATIONS_OFF', 'MESSAGE_NOTIFICATIONS_ON']
    }, activity);
  },


  /**
   * Creates a ShareActivty for the specified conversation
   * @param {Object} conversation
   * @param {Object} activity
   * @returns {ShareActivty}
   */
  makeShare: function makeShare(conversation, activity) {
    // if we pass activity as null then it does not take care of the
    // clientTempId created by the web-client while making the provisional
    // activity, hence we need to pass the activity which was created by the
    // web-client. This fixes the issue where the image activities do not come
    // back properly oriented from the server since the clientTempId is missing
    return _shareActivity2.default.create(conversation, activity, this.webex);
  },


  /**
   * Assigns an avatar to a room
   * @param {Object} conversation
   * @param {File} avatar
   * @returns {Promise<Activity>}
   */
  assign: function assign(conversation, avatar) {
    var _this11 = this;

    if ((avatar.size || avatar.length) > 1024 * 1024) {
      return _promise2.default.reject(new Error('Room avatars must be less than 1MB'));
    }

    return this._inferConversationUrl(conversation).then(function () {
      var activity = _shareActivity2.default.create(conversation, null, _this11.webex);

      activity.enableThumbnails = false;
      activity.add(avatar);

      return _this11.prepare(activity, {
        target: _this11.prepareConversation(conversation)
      });
    }).then(function (a) {
      // yes, this seems a little hacky; will likely be resolved as a result
      // of #213
      a.verb = 'assign';

      return _this11.submit(a);
    });
  },


  /**
   * Sets the typing status of the current user in a conversation
   *
   * @param {Object} conversation
   * @param {Object} options
   * @param {boolean} options.typing
   * @returns {Promise}
   */
  updateTypingStatus: function updateTypingStatus(conversation, options) {
    if (!conversation.id) {
      if (conversation.url) {
        conversation.id = conversation.url.split('/').pop();
      } else {
        return _promise2.default.reject(new Error('conversation: could not identify conversation'));
      }
    }

    var eventType = void 0;

    if (options.typing) {
      eventType = 'status.start_typing';
    } else {
      eventType = 'status.stop_typing';
    }

    var params = {
      method: 'POST',
      service: 'conversation',
      resource: 'status/typing',
      body: {
        conversationId: conversation.id,
        eventType: eventType
      }
    };

    return this.request(params);
  },


  /**
   * Shares files to the specified converstion
   * @param {Object} conversation
   * @param {ShareActivity|Array<File>} activity
   * @returns {Promise<Activity>}
   */
  share: function share(conversation, activity) {
    var _this12 = this;

    if ((0, _isArray3.default)(activity)) {
      activity = {
        object: {
          files: activity
        }
      };
    }

    return this._inferConversationUrl(conversation).then(function () {
      if (!(activity instanceof _shareActivity2.default)) {
        activity = _shareActivity2.default.create(conversation, activity, _this12.webex);
      }

      return _this12.prepare(activity, {
        target: _this12.prepareConversation(conversation)
      });
    }).then(function (a) {
      return _this12.submit(a);
    });
  },


  /**
   * Submits an activity to the conversation service
   * @param {Object} activity
   * @returns {Promise<Activity>}
   */
  submit: function submit(activity) {
    var params = {
      method: 'POST',
      service: 'conversation',
      resource: activity.verb === 'share' ? 'content' : 'activities',
      body: activity,
      qs: {
        personRefresh: true
      }
    };

    if (activity.verb === 'share') {
      (0, _assign2.default)(params.qs, {
        transcode: true,
        async: false
      });
    }

    // triggers user-activity to reset logout timer
    this.webex.trigger('user-activity');

    return this.request(params).then(function (res) {
      return res.body;
    });
  },


  /**
   * Remove the avatar from a room
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise}
   */
  unassign: function unassign(conversation, activity) {
    var _this13 = this;

    return this._inferConversationUrl(conversation).then(function () {
      return _this13.prepare(activity, {
        verb: 'unassign',
        target: _this13.prepareConversation(conversation),
        object: {
          objectType: 'content',
          files: {
            items: []
          }
        }
      });
    }).then(function (a) {
      return _this13.submit(a);
    });
  },


  /**
   * Mutes the mentions of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  unmuteMentions: function unmuteMentions(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_ON']
    }, activity);
  },


  /**
   * Mutes the messages of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  unmuteMessages: function unmuteMessages(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MESSAGE_NOTIFICATIONS_ON']
    }, activity);
  },
  update: function update(conversation, object, activity) {
    var _this14 = this;

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    return this._inferConversationUrl(conversation).then(function () {
      return _this14.prepare(activity, {
        verb: 'update',
        target: _this14.prepareConversation(conversation),
        object: object
      });
    }).then(function (a) {
      return _this14.submit(a);
    });
  },


  /**
   * Sets a new key for the conversation
   * @param {Object} conversation
   * @param {Key|string} key (optional)
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  updateKey: function updateKey(conversation, key, activity) {
    var _this15 = this;

    return this._inferConversationUrl(conversation).then(function () {
      return _this15.get(conversation, {
        activitiesLimit: 0,
        includeParticipants: true
      });
    }).then(function (c) {
      return _this15._updateKey(c, key, activity);
    });
  },


  /**
   * Sets a new key for the conversation
   * @param {Object} conversation
   * @param {Key|string} key (optional)
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @private
   * @returns {Promise<Activity>}
   */
  _updateKey: function _updateKey(conversation, key, activity) {
    var _this16 = this;

    return _promise2.default.resolve(key || this.webex.internal.encryption.kms.createUnboundKeys({ count: 1 })).then(function (keys) {
      var k = (0, _isArray3.default)(keys) ? keys[0] : keys;
      var params = {
        verb: 'updateKey',
        target: _this16.prepareConversation(conversation),
        object: {
          defaultActivityEncryptionKeyUrl: k.uri,
          objectType: 'conversation'
        }
      };

      // Reminder: the kmsResourceObjectUrl is only usable if there is
      // defaultActivityEncryptionKeyUrl.
      if (conversation.defaultActivityEncryptionKeyUrl) {
        params.kmsMessage = {
          method: 'update',
          resourceUri: '<KRO>',
          uri: k.uri
        };
      } else {
        params.kmsMessage = {
          method: 'create',
          uri: '/resources',
          userIds: (0, _map3.default)(conversation.participants.items, 'id'),
          keyUris: [k.uri]
        };
      }

      return _this16.prepare(activity, params).then(function (a) {
        return _this16.submit(a);
      });
    });
  },


  /**
   * @param {Object} payload
   * @param {Object} options
   * @private
   * @returns {Promise<Activity>}
   */
  _create: function _create(payload, options) {
    options = options || {};

    return this.request({
      method: 'POST',
      service: 'conversation',
      resource: 'conversations',
      body: payload,
      qs: {
        forceCreate: options.allowPartialCreation
      }
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise}
   */
  _createGrouped: function _createGrouped(params, options) {
    return this._create(this._prepareConversationForCreation(params), options);
  },


  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise}
   */
  _createOneOnOne: function _createOneOnOne(params) {
    var payload = this._prepareConversationForCreation(params);

    payload.tags = ['ONE_ON_ONE'];

    return this._create(payload);
  },


  /**
   * @param {Object} conversation
   * @private
   * @returns {Promise}
   */
  _inferConversationUrl: function _inferConversationUrl(conversation) {
    var _this17 = this;

    if (conversation.id) {
      return this.webex.internal.feature.getFeature('developer', 'web-high-availability').then(function (haMessagingEnabled) {
        if (haMessagingEnabled) {
          // recompute conversation URL each time as the host may have changed
          // since last usage
          return _this17.webex.internal.device.getServiceUrl('conversation').then(function (url) {
            conversation.url = url + '/conversations/' + conversation.id;

            return conversation;
          });
        }
        if (!conversation.url) {
          return _this17.webex.internal.device.getServiceUrl('conversation').then(function (url) {
            conversation.url = url + '/conversations/' + conversation.id;
            /* istanbul ignore else */
            if (process.env.NODE_ENV !== 'production') {
              _this17.logger.warn('conversation: inferred conversation url from conversation id; please pass whole conversation objects to Conversation methods');
            }

            return conversation;
          });
        }

        return _promise2.default.resolve(conversation);
      });
    }

    return _promise2.default.resolve(conversation);
  },


  /**
   * @param {Object} options
   * @private
   * @returns {Promise<Array<Activity>>}
   */
  _listActivities: function _listActivities(options) {
    return this._list({
      service: 'conversation',
      resource: options.mentions ? 'mentions' : 'activities',
      qs: (0, _omit3.default)(options, 'mentions')
    });
  },


  /**
   * @param {Object} options
   * @private
   * @returns {Promise<Array<Conversation>>}
   */
  _list: function _list(options) {
    var _this18 = this;

    options.qs = (0, _assign2.default)({
      personRefresh: true,
      uuidEntryFormat: true,
      activitiesLimit: 0,
      participantsLimit: 0
    }, options.qs);

    return this.request(options).then(function (res) {
      if (!res.body || !res.body.items || res.body.items.length === 0) {
        return [];
      }

      var items = res.body.items;


      if ((0, _last3.default)(items).published < items[0].published) {
        items.reverse();
      }

      return _promise2.default.all(items.map(function (item) {
        return _this18._recordUUIDs(item);
      }))
      // eslint-disable-next-line max-nested-callbacks
      .then(function () {
        return items;
      });
    });
  },


  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise<Conversation>}
   */
  _maybeCreateOneOnOneThenPost: function _maybeCreateOneOnOneThenPost(params, options) {
    var _this19 = this;

    return this.get((0, _defaults3.default)({
      // the use of uniq in Conversation#create guarantees participant[1] will
      // always be the other user
      user: params.participants[1]
    }), (0, _assign2.default)(options, { includeConvWithDeletedUserUUID: true, includeParticipants: true })).then(function (conversation) {
      if (params.comment || params.html) {
        return _this19.post(conversation, { content: params.html, displayName: params.comment }).then(function (activity) {
          conversation.activities.items.push(activity);

          return conversation;
        });
      }

      return conversation;
    }).catch(function (reason) {
      if (reason.statusCode !== 404) {
        return _promise2.default.reject(reason);
      }

      return _this19._createOneOnOne(params);
    });
  },


  /**
   * @param {Object} params
   * @private
   * @returns {Object}
   */
  _prepareConversationForCreation: function _prepareConversationForCreation(params) {
    var _this20 = this;

    var payload = {
      activities: {
        items: [this.expand('create')]
      },
      objectType: 'conversation',
      kmsMessage: {
        method: 'create',
        uri: '/resources',
        userIds: (0, _cloneDeep3.default)(params.participants),
        keyUris: []
      }
    };

    if (params.displayName) {
      payload.displayName = params.displayName;
    }

    params.participants.forEach(function (participant) {
      payload.activities.items.push(_this20.expand('add', {
        objectType: 'person',
        id: participant
      }));
    });

    if (params.comment) {
      payload.activities.items.push(this.expand('post', {
        objectType: 'comment',
        content: params.html,
        displayName: params.comment
      }));
    }

    return payload;
  },


  /**
   * @param {Object} conversation
   * @private
   * @returns {Promise}
   */
  _recordUUIDs: function _recordUUIDs(conversation) {
    var _this21 = this;

    if (!conversation.participants || !conversation.participants.items) {
      return _promise2.default.resolve(conversation);
    }

    return _promise2.default.all(conversation.participants.items.map(function (participant) {
      // ROOMs do not have email addresses, so there's no point attempting to
      // record their UUIDs.
      if (participant.type === 'ROOM') {
        return _promise2.default.resolve();
      }

      return _this21.webex.internal.user.recordUUID(participant).catch(function (err) {
        return _this21.logger.warn('Could not record uuid for ' + (participant.id || participant.entryUUID), err);
      });
    }));
  },
  version: '1.72.6'
});

['favorite', 'hide', 'lock', 'mute', 'unfavorite', 'unhide', 'unlock', 'unmute'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitSimpleActivity(conversation, activity) {
    var _this22 = this;

    return this._inferConversationUrl(conversation).then(function () {
      return _this22.prepare(activity, {
        verb: verb,
        object: _this22.prepareConversation(conversation)
      });
    }).then(function (a) {
      return _this22.submit(a);
    });
  };
});

['assignModerator', 'unassignModerator'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitModerationChangeActivity(conversation, moderator, activity) {
    var _this23 = this;

    return _promise2.default.all([this._inferConversationUrl(conversation), moderator ? this.webex.internal.user.asUUID(moderator) : this.webex.internal.device.userId]).then(function (_ref) {
      var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
          c = _ref2[0],
          userId = _ref2[1];

      return _this23.prepare(activity, {
        verb: verb,
        target: _this23.prepareConversation(c),
        object: {
          id: userId,
          objectType: 'person'
        }
      });
    }).then(function (a) {
      return _this23.submit(a);
    });
  };
});

/**
 * Sets/unsets space property for convo
 * @param {Object} conversation
 * @param {string} tag
 * @param {Activity} activity
 * @returns {Promise<Activity>}
 */
['setSpaceProperty', 'unsetSpaceProperty'].forEach(function (fnName) {
  var verb = fnName.startsWith('set') ? 'set' : 'unset';

  Conversation.prototype[fnName] = function submitSpacePropertyActivity(conversation, tag, activity) {
    var _this24 = this;

    if (!(0, _isString3.default)(tag)) {
      return _promise2.default.reject(new Error('`tag` must be a string'));
    }

    return this._inferConversationUrl(conversation).then(function () {
      return _this24.prepare(activity, {
        verb: verb,
        target: _this24.prepareConversation(conversation),
        object: {
          tags: [tag],
          objectType: 'spaceProperty'
        }
      });
    }).then(function (a) {
      return _this24.submit(a);
    });
  };
});

['tag', 'untag'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitObjectActivity(conversation, object, activity) {
    var _this25 = this;

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    var c = this.prepareConversation(conversation);

    return this._inferConversationUrl(conversation).then(function () {
      return _this25.prepare(activity, {
        verb: verb,
        target: c,
        object: (0, _assign2.default)(c, object)
      });
    }).then(function (a) {
      return _this25.submit(a);
    });
  };
});

exports.default = Conversation;
//# sourceMappingURL=conversation.js.map
