'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _dec, _dec2, _dec3, _dec4, _desc, _value, _obj; /*!
                                                     * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
                                                     */

var _common = require('@webex/common');

var _webexCore = require('@webex/webex-core');

var _userUuidBatcher = require('./user-uuid-batcher');

var _userUuidBatcher2 = _interopRequireDefault(_userUuidBatcher);

var _userUuidStore = require('./user-uuid-store');

var _userUuidStore2 = _interopRequireDefault(_userUuidStore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * @class
 */
var User = _webexCore.WebexPlugin.extend((_dec = (0, _webexCore.waitForValue)('@'), _dec2 = (0, _common.oneFlight)({ keyFactory: function keyFactory(email, options) {
    return email + String(options && options.create);
  } }), _dec3 = (0, _webexCore.persist)('@'), _dec4 = (0, _common.deprecated)('Use User#verify()'), (_obj = {
  namespace: 'User',

  children: {
    batcher: _userUuidBatcher2.default
  },

  props: {
    /**
     * Indicates if the current user is known to have a password.
     * @instance
     * @memberof User
     * @type {boolean}
     */
    hasPassword: {
      default: false,
      type: 'boolean'
    }
  },

  session: {
    store: {
      default: function _default() {
        return new _userUuidStore2.default();
      },

      type: 'any'
    }
  },

  /**
   * Activates a Webex user account and exchanges for user token.
   * @instance
   * @memberof User
   * @param {Object} options
   * @param {Object} options.confirmationCode (required -- optional if verification token is provided)
   * @param {Object} options.id (required -- optional if verification token is provided)
   * @param {Object} options.verificationToken (required -- optional if uuid and verification token provided)
   * @param {Object} options.email (required with verificationToken for Federation/global user)
   * @returns {Promise} Resolves with a userSession
   */
  activate: function activate() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!(options.verificationToken || options.confirmationCode && options.id)) {
      return _promise2.default.reject(new Error('either options.verificationToken is required or both options.confirmationCode and options.id are required'));
    }

    // Email is required for federation
    if (this.webex.config.credentials.federation && !options.email) {
      return _promise2.default.reject(new Error('email is required with federation option'));
    }

    options.scope = this.webex.config.credentials.scope;

    // if we have options.email and options.verificationToken
    // and Federation flag is enabled, flag that we need to
    // lookup user's CI.
    var needsCILookup = this.webex.config.credentials.federation && options.email && options.verificationToken;

    return this.getUserCI(options.email, needsCILookup).then(function () {
      var activateOptions = (0, _assign2.default)({}, options);

      delete activateOptions.email;

      return _this.request({
        uri: _this.webex.config.credentials.activationUrl,
        method: 'POST',
        body: activateOptions,
        auth: {
          user: _this.webex.config.credentials.client_id,
          pass: _this.webex.config.credentials.client_secret,
          sendImmediately: true
        }
      }).then(function (res) {
        _this.webex.credentials.set({ supertoken: res.body.tokenData });

        return res.body;
      });
    });
  },


  /**
   * Converts a user-identifying object to a uuid, perhaps by doing a network
   * lookup
   * @param {string|Object} user
   * @param {Object} options
   * @param {boolean} options.create if true, ensures the return UUID refers to
   * an existing user (rather than creating one deterministically based on email
   * address), even if that user must be created
   * @returns {Promise<string>}
   */
  asUUID: function asUUID(user, options) {
    var _this2 = this;

    if (!user) {
      return _promise2.default.reject(new Error('`user` is required'));
    }

    if ((0, _isArray3.default)(user)) {
      return _promise2.default.all(user.map(function (u) {
        return _this2.asUUID(u, options);
      }));
    }

    var id = this._extractUUID(user);

    if (!(options && options.force) && _common.patterns.uuid.test(id)) {
      return _promise2.default.resolve(id);
    }

    var email = this._extractEmailAddress(user);

    if (!_common.patterns.email.test(email)) {
      return _promise2.default.reject(new Error('Provided user object does not appear to identify a user'));
    }

    return this.getUUID(email, options);
  },


  /**
   * Requests a uuid from the api
   * @param {string} email
   * @param {Object} options
   * @param {boolean} options.create
   * @returns {Promise<string>}
   */
  fetchUUID: function fetchUUID(email, options) {
    var _this3 = this;

    return this.batcher.request({
      email: email,
      create: options && options.create
    }).then(function (user) {
      return _this3.recordUUID((0, _assign2.default)({ emailAddress: email }, user)).then(function () {
        return user.id;
      });
    });
  },


  /**
   * Fetches details about the current user
   * @returns {Promise<Object>}
   */
  get: function get() {
    var _this4 = this;

    return this.request({
      service: 'conversation',
      resource: 'users'
    }).then(function (res) {
      return res.body;
    }).then((0, _common.tap)(function (user) {
      return _this4.recordUUID({
        id: user.id,
        // CI endpoints don't use the same user format as actors, so, email may
        // be in one of a few fields
        emailAddress: user.email || user.emailAddress
      });
    }));
  },
  getUUID: function getUUID(email, options) {
    var _this5 = this;

    return this.store.getByEmail(email).then(function (user) {
      if (options && options.create && !user.userExists) {
        return _promise2.default.reject(new Error('User for specified email cannot be confirmed to exist'));
      }

      if (!user.id) {
        return _promise2.default.reject(new Error('No id recorded for specified user'));
      }

      return user.id;
    }).catch(function () {
      return _this5.fetchUUID(email, options);
    });
  },
  initialize: function initialize() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (0, _apply2.default)(_webexCore.WebexPlugin.prototype.initialize, this, args);
  },


  /**
   * Caches the uuid for the specified email address
   * @param {Object} user
   * @param {string} user.id
   * @param {string} user.emailAddress
   * @returns {Promise}
   */
  recordUUID: function recordUUID(user) {
    if (!user) {
      return _promise2.default.reject(new Error('`user` is required'));
    }

    if (!user.id) {
      return _promise2.default.reject(new Error('`user.id` is required'));
    }

    if (!_common.patterns.uuid.test(user.id)) {
      return _promise2.default.reject(new Error('`user.id` must be a uuid'));
    }

    if (!user.emailAddress) {
      return _promise2.default.reject(new Error('`user.emailAddress` is required'));
    }

    if (!_common.patterns.email.test(user.emailAddress)) {
      return _promise2.default.reject(new Error('`user.emailAddress` must be an email address'));
    }

    return this.store.add(user);
  },
  register: function register() {
    return this.verify.apply(this, arguments);
  },


  /**
   * Updates a user's password with webex.
   * @instance
   * @memberof User
   * @param {Object} options
   * @param {string} options.password (required)
   * @param {string} options.email (required when federation enabled)
   * @returns {Promise} Resolves with complete user object containing new password
   */
  setPassword: function setPassword(options) {
    var _this6 = this;

    options = options || {};
    if (!options.password) {
      return _promise2.default.reject(new Error('`options.password` is required'));
    }

    // Email is required for federation
    if (this.webex.config.credentials.federation && !options.email) {
      return _promise2.default.reject(new Error('email is required with federation option'));
    }

    return this.getUserCI(options.email, this.webex.config.credentials.federation).then(function () {
      return _this6.webex.credentials.getUserToken();
    }).then(function (token) {
      return _this6.request({
        uri: _this6.webex.config.credentials.setPasswordUrl + '/' + _this6.webex.internal.device.userId,
        method: 'PATCH',
        headers: {
          authorization: token.toString()
        },
        body: {
          schemas: ['urn:scim:schemas:core:1.0', 'urn:scim:schemas:extension:cisco:commonidentity:1.0'],
          password: options.password
        }
      });
    }).then(function (res) {
      _this6.hasPassword = true;

      return res.body;
    });
  },


  /**
   * Updates the current user's display name
   * @param {Object} options
   * @param {string} options.displayName
   * @returns {Promise<Object>}
   */
  update: function update(options) {
    options = options || {};
    if (!options.displayName) {
      return _promise2.default.reject(new Error('`options.displayName` is required'));
    }

    return this.request({
      method: 'PATCH',
      service: 'conversation',
      resource: 'users/user',
      body: options
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Determines if the specified user needs to signup or can signin.
   * Triggers activation email if client credentials are used
   * @param {Object} options
   * @param {string} options.email (required)
   * @param {string} options.reqId required if need to check email status
   * @param {string} options.preloginId
   * @returns {Promise<Object>}
   */
  verify: function verify(options) {
    var _this7 = this;

    options = (0, _assign2.default)({}, this.config.verifyDefaults, options);
    if (!options.email) {
      return _promise2.default.reject(new Error('`options.email` is required'));
    }

    // For Federation, there is only one Atlas, which we get the user's CI from
    // Use default CI URL to start, will be re-set after we retrieve user's CI
    var orgIdentityUrl = this.webex.config.credentials.identity.url;
    var orgIdbrokerUrl = this.webex.config.credentials.idbroker.url;

    if (this.webex.config.credentials.federation) {
      this.webex.config.credentials.idbroker.url = this.webex.config.credentials.idbroker.defaultUrl;
      this.webex.config.credentials.identity.url = this.webex.config.credentials.identity.defaultUrl;
    }

    return this.webex.credentials.getUserToken().catch(function () {
      return _this7.webex.credentials.getClientToken();
    }).then(function (token) {
      return _this7.request({
        service: 'atlas',
        resource: 'users/activations',
        method: 'POST',
        headers: {
          authorization: token.toString(),
          'x-prelogin-userid': options.preloginId
        },
        body: options,
        shouldRefreshAccessToken: false
      });
    }).then(function (res) {
      if (res.body.hasPassword || res.body.sso) {
        _this7.hasPassword = true;
      }

      // if we have a different CI than default, and Federation is enabled,
      // update the CI to what was returned by Atlas.
      if (_this7.webex.config.credentials.federation && res.body.userEntities) {
        _this7.webex.config.credentials.idbroker.url = res.body.userEntities.idBrokerUrl;
        _this7.webex.config.credentials.identity.url = res.body.userEntities.identityUrl;
      }

      return res.body;
    }).catch(function (reason) {
      // reset CI on failure
      if (_this7.webex.config.credentials.federation) {
        _this7.webex.config.credentials.idbroker.url = orgIdbrokerUrl;
        _this7.webex.config.credentials.identity.url = orgIdentityUrl;
      }

      return _promise2.default.reject(reason);
    });
  },


  /**
   * If the passed-in lookupCI is true, retrieve the user's
   * CI from Atlas and return the URL's via a Promise.
   * Otherwise, return current CI in config via a Promise.
   * Useful in a Promise chain to retrieve the CI based on
   * conditions like Federation enabled, and suppresses sending
   * an additional email to the user, since this is just a
   * look-up.
   * @param {string} email (required)
   * @param {boolean} lookupCI (required)
   * @returns {Promise<Object>}
   */
  getUserCI: function getUserCI(email, lookupCI) {
    if (lookupCI) {
      // call verify first to get the user's CI, but suppress sending another email
      var verifyOptions = {
        email: email,
        suppressEmail: true
      };

      return this.verify(verifyOptions).then(function (res) {
        return _promise2.default.resolve(res.userEntities);
      });
    }

    return _promise2.default.resolve({
      idBrokerUrl: this.webex.config.credentials.idbroker.url,
      identityUrl: this.webex.config.credentials.identity.url
    });
  },


  /**
   * Extracts the uuid from a user identifying object
   * @param {string|Object} user
   * @private
   * @returns {string}
   */
  _extractUUID: function _extractUUID(user) {
    return user.entryUUID || user.id || user;
  },


  /**
   * Extracts the email address from a user identifying object
   * @param {string|Object} user
   * @private
   * @returns {string}
   */
  _extractEmailAddress: function _extractEmailAddress(user) {
    return user.email || user.emailAddress || user.entryEmail || user;
  },
  version: '1.72.6'
}, (_applyDecoratedDescriptor(_obj, 'activate', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'activate'), _obj), _applyDecoratedDescriptor(_obj, 'getUUID', [_dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'getUUID'), _obj), _applyDecoratedDescriptor(_obj, 'initialize', [_dec3], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initialize'), _obj), _applyDecoratedDescriptor(_obj, 'register', [_dec4], (0, _getOwnPropertyDescriptor2.default)(_obj, 'register'), _obj)), _obj)));

exports.default = User;
//# sourceMappingURL=user.js.map
