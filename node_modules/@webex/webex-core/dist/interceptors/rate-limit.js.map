{"version":3,"sources":["rate-limit.js"],"names":["rateLimitExpiryTime","idBrokerRegex","RateLimitInterceptor","webex","args","set","options","isRateLimited","uri","reject","Error","resolve","reason","statusCode","includes","setRateLimitExpiry","extractRetryAfterTime","milliMultiplier","retryAfter","headers","apiName","getApiName","currTimeMilli","Date","getTime","expiry","dict","get","expiryTime","undefined","results","match","getRateLimitStatus","Interceptor"],"mappings":"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","file":"rate-limit.js","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {Interceptor} from '@webex/http-core';\n\n// contains the system time in milliseconds at which the retry after associated with a 429 expires\n// mapped by the API name, e.g.: idbroker.webex.com/doStuff would be mapped as 'doStuff'\nconst rateLimitExpiryTime = new WeakMap();\n\n// extracts the common identity API being called\nconst idBrokerRegex = /.*(idbroker|identity)(bts)?.ciscospark.com\\/([^/]+)/;\n\n/**\n * @class\n */\nexport default class RateLimitInterceptor extends Interceptor {\n  /**\n   * @returns {RateLimitInterceptor}\n   */\n  static create() {\n    return new RateLimitInterceptor({webex: this});\n  }\n\n  /**\n  * constructor\n  * @param {mixed} args\n  * @returns {Exception}\n  */\n  constructor(...args) {\n    super(...args);\n    rateLimitExpiryTime.set(this, new Map());\n  }\n\n  /**\n   * @see {@link Interceptor#onRequest}\n   * @param {Object} options\n   * @returns {Object}\n   */\n  onRequest(options) {\n    if (this.isRateLimited(options.uri)) {\n      return Promise.reject(new Error(`API rate limited ${options.uri}`));\n    }\n\n    return Promise.resolve(options);\n  }\n\n  /**\n   * @see {@link Interceptor#onResponseError}\n   * @param {Object} options\n   * @param {Error} reason\n   * @returns {Object}\n   */\n  onResponseError(options, reason) {\n    if (reason.statusCode === 429 && (options.uri.includes('idbroker') || options.uri.includes('identity'))) {\n      // set the retry after in the map, setting to milliseconds\n      this.setRateLimitExpiry(options.uri, this.extractRetryAfterTime(options));\n    }\n\n    return Promise.reject(reason);\n  }\n\n  /**\n   * @param {object} options associated with the request\n   * @returns {number} retry after time in milliseconds\n   */\n  extractRetryAfterTime(options) {\n    // 1S * 1K === 1MS\n    const milliMultiplier = 1000;\n    const retryAfter = options.headers['retry-after'] || null;\n\n    // set 60 retry if no usable time defined\n    if (retryAfter === null || retryAfter <= 0) {\n      return 60 * milliMultiplier;\n    }\n    // set max to 3600 S (1 hour) if greater than 1 hour\n    if (retryAfter > 3600) {\n      return 3600 * milliMultiplier;\n    }\n\n    return retryAfter * milliMultiplier;\n  }\n\n  /**\n   * Set the system time at which the rate limiting\n   * will expire in the rateLimitExpiryTime map.\n   * Assumes retryAfter is in milliseconds\n   * @param {string} uri API issuing the rate limiting\n   * @param {number} retryAfter milliseconds until rate limiting expires\n   * @returns {bool} true is value was successfully set\n   */\n  setRateLimitExpiry(uri, retryAfter) {\n    const apiName = this.getApiName(uri);\n\n    if (!apiName) {\n      return false;\n    }\n\n    const currTimeMilli = new Date().getTime();\n    const expiry = currTimeMilli + retryAfter;\n    const dict = rateLimitExpiryTime.get(this);\n\n    return dict.set(apiName, expiry);\n  }\n\n  /**\n   * returns true if the API is currently rate limited\n   * @param {string} uri\n   * @returns {Boolean} indicates whether or not the API is rate currently rate limited\n   */\n  getRateLimitStatus(uri) {\n    const apiName = this.getApiName(uri);\n\n    if (!apiName) {\n      return false;\n    }\n\n    const currTimeMilli = new Date().getTime();\n    const dict = rateLimitExpiryTime.get(this);\n    const expiryTime = dict.get(apiName);\n\n    // if no rate limit expiry has been registered in the map, return false.\n    if (expiryTime === undefined) {\n      return false;\n    }\n\n    // return true, indicating rate limiting, if the system time is less than the expiry time\n    return currTimeMilli < dict.get(apiName);\n  }\n\n  /**\n   * split the URI and returns the API name of idBroker\n   * @param {string} uri\n   * @returns {string}\n   */\n  getApiName(uri) {\n    if (!uri) {\n      return null;\n    }\n\n    const results = uri.match(idBrokerRegex);\n\n    if (!results) {\n      return null;\n    }\n\n    // group 0 = full match of URL, group 1 = identity or idbroker base\n    // group 2 = api name\n    return results[2];\n  }\n\n  /**\n   * check URI against list of currently rate limited\n   * URIs, and determines if retry-after\n   * @param {String} uri pattern to check\n   * @returns {bool}\n   */\n  isRateLimited(uri) {\n    // determine if the URI is associated with a common identity API\n    if (uri && (uri.includes('idbroker') || uri.includes('identity'))) {\n      return this.getRateLimitStatus(uri);\n    }\n\n    return false;\n  }\n}\n"]}